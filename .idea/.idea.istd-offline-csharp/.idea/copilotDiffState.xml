<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/dto/CsrConfigDto.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/dto/CsrConfigDto.cs" />
              <option name="originalContent" value="using Newtonsoft.Json;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.DTOs&#10;{&#10;    public class CsrConfigDto&#10;    {&#10;&#10;        private string enName;&#10;&#10;        private string serialNumber;&#10;        &#10;        [JsonProperty(&quot;keySize&quot;)]&#10;        private int keySize = 2048;&#10;        &#10;        [JsonProperty(&quot;templateOid&quot;)]&#10;        private string templateOid;&#10;&#10;        [JsonProperty(&quot;major&quot;)] &#10;        private int majorVersion;&#10;&#10;        [JsonProperty(&quot;minor&quot;)] &#10;        private int minorVersion;&#10;&#10;        public CsrConfigDto() { }&#10;&#10;        public string getEnName()&#10;        {&#10;            return enName;&#10;        }&#10;&#10;        public void setEnName(string enName)&#10;        {&#10;            this.enName = enName;&#10;        }&#10;&#10;        public string getSerialNumber()&#10;        {&#10;            return serialNumber;&#10;        }&#10;&#10;        public void setSerialNumber(string serialNumber)&#10;        {&#10;            this.serialNumber = serialNumber;&#10;        }&#10;&#10;        public string getKeyPassword()&#10;        {&#10;            return keyPassword;&#10;        }&#10;&#10;        public void setKeyPassword(string keyPassword)&#10;        {&#10;            this.keyPassword = keyPassword;&#10;        }&#10;&#10;        public int getKeySize()&#10;        {&#10;            return keySize;&#10;        }&#10;&#10;        public void setKeySize(int keySize)&#10;        {&#10;            this.keySize = keySize;&#10;        }&#10;&#10;        public string getTemplateOid()&#10;        {&#10;            return templateOid;&#10;        }&#10;&#10;        public void setTemplateOid(string templateOid)&#10;        {&#10;            this.templateOid = templateOid;&#10;        }&#10;&#10;        public int getMajorVersion()&#10;        {&#10;            return majorVersion;&#10;        }&#10;&#10;        public void setMajorVersion(int majorVersion)&#10;        {&#10;            this.majorVersion = majorVersion;&#10;        }&#10;&#10;        public int getMinorVersion()&#10;        {&#10;            return minorVersion;&#10;        }&#10;&#10;        public void setMinorVersion(int minorVersion)&#10;        {&#10;            this.minorVersion = minorVersion;&#10;        }&#10;&#10;        public string getPassword()&#10;        {&#10;            return keyPassword;&#10;        }&#10;&#10;        public string getSubjectDn()&#10;        {&#10;            if (string.IsNullOrWhiteSpace(enName) || string.IsNullOrWhiteSpace(serialNumber))&#10;            {&#10;                return null;&#10;            }&#10;&#10;            return $&quot;CN={enName.Trim()}, O=Government of Jordan, OU=eID, SerialNumber={serialNumber.Trim()}, C=JO&quot;;&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using Newtonsoft.Json;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.DTOs&#10;{&#10;    public class CsrConfigDto&#10;    {&#10;&#10;        private string enName;&#10;&#10;        private string serialNumber;&#10;        &#10;        [JsonProperty(&quot;keySize&quot;)]&#10;        private int keySize = 2048;&#10;        &#10;        [JsonProperty(&quot;templateOid&quot;)]&#10;        private string templateOid;&#10;&#10;        [JsonProperty(&quot;major&quot;)] &#10;        private int majorVersion;&#10;&#10;        [JsonProperty(&quot;minor&quot;)] &#10;        private int minorVersion;&#10;&#10;        public CsrConfigDto() { }&#10;&#10;        public string getEnName()&#10;        {&#10;            return enName;&#10;        }&#10;&#10;        public void setEnName(string enName)&#10;        {&#10;            this.enName = enName;&#10;        }&#10;&#10;        public string getSerialNumber()&#10;        {&#10;            return serialNumber;&#10;        }&#10;&#10;        public void setSerialNumber(string serialNumber)&#10;        {&#10;            this.serialNumber = serialNumber;&#10;        }&#10;&#10;        public int getKeySize()&#10;        {&#10;            return keySize;&#10;        }&#10;&#10;        public void setKeySize(int keySize)&#10;        {&#10;            this.keySize = keySize;&#10;        }&#10;&#10;        public string getTemplateOid()&#10;        {&#10;            return templateOid;&#10;        }&#10;&#10;        public void setTemplateOid(string templateOid)&#10;        {&#10;            this.templateOid = templateOid;&#10;        }&#10;&#10;        public int getMajorVersion()&#10;        {&#10;            return majorVersion;&#10;        }&#10;&#10;        public void setMajorVersion(int majorVersion)&#10;        {&#10;            this.majorVersion = majorVersion;&#10;        }&#10;&#10;        public int getMinorVersion()&#10;        {&#10;            return minorVersion;&#10;        }&#10;&#10;        public void setMinorVersion(int minorVersion)&#10;        {&#10;            this.minorVersion = minorVersion;&#10;        }&#10;&#10;        public string getSubjectDn()&#10;        {&#10;            if (string.IsNullOrWhiteSpace(enName) || string.IsNullOrWhiteSpace(serialNumber))&#10;            {&#10;                return null;&#10;            }&#10;&#10;            return $&quot;CN={enName.Trim()}, O=Government of Jordan, OU=eID, SerialNumber={serialNumber.Trim()}, C=JO&quot;;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/helper/DigitalSignatureHelper.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/helper/DigitalSignatureHelper.cs" />
              <option name="originalContent" value="using System.Security.Cryptography;&#10;using ISTD_OFFLINE_CSHARP.ActionProcessor.impl;&#10;using ISTD_OFFLINE_CSHARP.DTOs;&#10;using ISTD_OFFLINE_CSHARP.utils;&#10;using Microsoft.Extensions.Logging;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.helper&#10;{&#10;    public class DigitalSignatureHelper&#10;    {&#10;        private readonly ILogger log;&#10;&#10;        public DigitalSignatureHelper()&#10;        {&#10;            this.log = LoggingUtils.getLoggerFactory().CreateLogger&lt;DigitalSignatureHelper&gt;();&#10;        }&#10;&#10;        public DigitalSignature getDigitalSignature(RSA privateKey, string invoiceHash)&#10;        {&#10;            byte[] xmlHashingBytes = Convert.FromBase64String(invoiceHash);&#10;            byte[] digitalSignatureBytes = signRSA(privateKey, xmlHashingBytes);&#10;&#10;            string digitalSignature = Convert.ToBase64String(digitalSignatureBytes);&#10;            return new DigitalSignature(digitalSignature, xmlHashingBytes);&#10;        }&#10;&#10;        private byte[] signRSA(RSA privateKey, byte[] messageHash)&#10;        {&#10;            try&#10;            {&#10;                return privateKey.SignHash(messageHash, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                log.LogError(ex, &quot;Failed to sign with RSA&quot;);&#10;                throw;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Security.Cryptography;&#10;using ISTD_OFFLINE_CSHARP.ActionProcessor.impl;&#10;using ISTD_OFFLINE_CSHARP.DTOs;&#10;using ISTD_OFFLINE_CSHARP.utils;&#10;using Microsoft.Extensions.Logging;&#10;using System.Text;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.helper&#10;{&#10;    public class DigitalSignatureHelper&#10;    {&#10;        private readonly ILogger log;&#10;&#10;        public DigitalSignatureHelper()&#10;        {&#10;            this.log = LoggingUtils.getLoggerFactory().CreateLogger&lt;DigitalSignatureHelper&gt;();&#10;        }&#10;&#10;        public DigitalSignature getDigitalSignature(RSA privateKey, string invoiceHash)&#10;        {&#10;            // Match Java exactly: decode the base64 after converting to UTF-8 bytes first&#10;            byte[] invoiceHashBytes = Encoding.UTF8.GetBytes(invoiceHash);&#10;            byte[] xmlHashingBytes = Convert.FromBase64String(Encoding.UTF8.GetString(invoiceHashBytes));&#10;            &#10;            byte[] digitalSignatureBytes = signWithPrivateKey(privateKey, xmlHashingBytes);&#10;&#10;            string digitalSignature = Convert.ToBase64String(digitalSignatureBytes);&#10;            return new DigitalSignature(digitalSignature, xmlHashingBytes);&#10;        }&#10;&#10;        private byte[] signWithPrivateKey(RSA privateKey, byte[] messageHash)&#10;        {&#10;            try&#10;            {&#10;                // Use SignData instead of SignHash to match Java's Signature.update() + sign() behavior&#10;                // This performs raw signature on the data without additional hashing&#10;                return privateKey.SignData(messageHash, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                log.LogError(ex, &quot;Failed to sign with RSA&quot;);&#10;                throw;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/utils/ECDSAUtils.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/utils/ECDSAUtils.cs" />
              <option name="originalContent" value="using System;&#10;using Org.BouncyCastle.Asn1;&#10;using Org.BouncyCastle.Asn1.Sec;&#10;using Org.BouncyCastle.Asn1.X9;&#10;using Org.BouncyCastle.Crypto;&#10;using Org.BouncyCastle.Crypto.Generators;&#10;using Org.BouncyCastle.Crypto.Parameters;&#10;using Org.BouncyCastle.Math;&#10;using Org.BouncyCastle.Security;&#10;using Org.BouncyCastle.OpenSsl;&#10;using System.IO;&#10;using System.Security.Cryptography;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.utils;&#10;public class ECDSAUtils&#10;{&#10;    public static AsymmetricCipherKeyPair getKeyPair()&#10;    {&#10;        var curve = SecNamedCurves.GetByName(&quot;secp256k1&quot;);&#10;        var domainParams = new ECDomainParameters(curve.Curve, curve.G, curve.N, curve.H);&#10;&#10;        &#10;        var keyGen = new ECKeyPairGenerator();&#10;        var secureRandom = new SecureRandom();&#10;        var keyGenParam = new ECKeyGenerationParameters(domainParams, secureRandom);&#10;        keyGen.Init(keyGenParam);&#10;        &#10;        return keyGen.GenerateKeyPair();&#10;    }&#10;&#10;    public static RSA getPrivateKey(string base64Key)&#10;    {&#10;        try&#10;        {&#10;            byte[] keyBytes = Convert.FromBase64String(base64Key);&#10;            &#10;            // Try to load as encrypted PKCS#8 first&#10;            try&#10;            {&#10;                RSA rsa = RSA.Create();&#10;                rsa.ImportPkcs8PrivateKey(keyBytes, out _);&#10;                return rsa;&#10;            }&#10;            catch&#10;            {&#10;                // If that fails, try as encrypted PKCS#8 with empty password&#10;                try&#10;                {&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportEncryptedPkcs8PrivateKey(&quot;&quot;, keyBytes, out _);&#10;                    return rsa;&#10;                }&#10;                catch&#10;                {&#10;                    // If both fail, try as RSA private key&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportRSAPrivateKey(keyBytes, out _);&#10;                    return rsa;&#10;                }&#10;            }&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            throw new ArgumentException(&quot;Failed to parse RSA private key: &quot; + ex.Message, ex);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using Org.BouncyCastle.Asn1;&#10;using Org.BouncyCastle.Asn1.Sec;&#10;using Org.BouncyCastle.Asn1.X9;&#10;using Org.BouncyCastle.Crypto;&#10;using Org.BouncyCastle.Crypto.Generators;&#10;using Org.BouncyCastle.Crypto.Parameters;&#10;using Org.BouncyCastle.Math;&#10;using Org.BouncyCastle.Security;&#10;using Org.BouncyCastle.OpenSsl;&#10;using System.IO;&#10;using System.Security.Cryptography;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.utils;&#10;public class ECDSAUtils&#10;{&#10;    public static AsymmetricCipherKeyPair getKeyPair()&#10;    {&#10;        var curve = SecNamedCurves.GetByName(&quot;secp256k1&quot;);&#10;        var domainParams = new ECDomainParameters(curve.Curve, curve.G, curve.N, curve.H);&#10;&#10;        &#10;        var keyGen = new ECKeyPairGenerator();&#10;        var secureRandom = new SecureRandom();&#10;        var keyGenParam = new ECKeyGenerationParameters(domainParams, secureRandom);&#10;        keyGen.Init(keyGenParam);&#10;        &#10;        return keyGen.GenerateKeyPair();&#10;    }&#10;&#10;    public static RSA getPrivateKey(string base64Key)&#10;    {&#10;        try&#10;        {&#10;            byte[] keyBytes = Convert.FromBase64String(base64Key);&#10;            &#10;            // Try to load as encrypted PKCS#8 first&#10;            try&#10;            {&#10;                RSA rsa = RSA.Create();&#10;                rsa.ImportPkcs8PrivateKey(keyBytes, out _);&#10;                return rsa;&#10;            }&#10;            catch&#10;            {&#10;                // If that fails, try as encrypted PKCS#8 with empty password&#10;                try&#10;                {&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportEncryptedPkcs8PrivateKey(&quot;&quot;, keyBytes, out _);&#10;                    return rsa;&#10;                }&#10;                catch&#10;                {&#10;                    // If both fail, try as RSA private key&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportRSAPrivateKey(keyBytes, out _);&#10;                    return rsa;&#10;                }&#10;            }&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            throw new ArgumentException(&quot;Failed to parse RSA private key: &quot; + ex.Message, ex);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/utils/PrivateKeyUtil.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/utils/PrivateKeyUtil.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Security.Cryptography;&#10;using System.Text;&#10;using ISTD_OFFLINE_CSHARP.utils;&#10;using Microsoft.Extensions.Logging;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.utils&#10;{&#10;    public static class PrivateKeyUtil&#10;    {&#10;        private static readonly ILogger log = LoggingUtils.getLoggerFactory().CreateLogger(typeof(PrivateKeyUtil));&#10;&#10;        public static RSA loadPrivateKey(string privateKeyContent, string password)&#10;        {&#10;            try&#10;            {&#10;                if (privateKeyContent.Contains(&quot;-----BEGIN ENCRYPTED PRIVATE KEY-----&quot;))&#10;                {&#10;                    return loadEncryptedPKCS8PrivateKey(privateKeyContent, password);&#10;                }&#10;                else if (privateKeyContent.Contains(&quot;-----BEGIN PRIVATE KEY-----&quot;))&#10;                {&#10;                    return loadUnencryptedPKCS8PrivateKey(privateKeyContent);&#10;                }&#10;                else&#10;                {&#10;                    return loadPrivateKeyFromBase64(privateKeyContent, password);&#10;                }&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                log.LogError(e, &quot;Failed to load private key&quot;);&#10;                throw new Exception(&quot;Unable to load private key: &quot; + e.Message, e);&#10;            }&#10;        }&#10;&#10;        private static RSA loadEncryptedPKCS8PrivateKey(string privateKeyContent, string password)&#10;        {&#10;            if (string.IsNullOrWhiteSpace(password))&#10;            {&#10;                throw new ArgumentException(&quot;Password is required for encrypted private key&quot;);&#10;            }&#10;&#10;            string cleanKey = privateKeyContent&#10;                .Replace(&quot;-----BEGIN ENCRYPTED PRIVATE KEY-----&quot;, &quot;&quot;)&#10;                .Replace(&quot;-----END ENCRYPTED PRIVATE KEY-----&quot;, &quot;&quot;)&#10;                .Replace(&quot;\n&quot;, &quot;&quot;)&#10;                .Replace(&quot;\r&quot;, &quot;&quot;)&#10;                .Replace(&quot; &quot;, &quot;&quot;);&#10;&#10;            byte[] keyBytes = Convert.FromBase64String(cleanKey);&#10;&#10;            RSA rsa = RSA.Create();&#10;            rsa.ImportEncryptedPkcs8PrivateKey(password, keyBytes, out _);&#10;            return rsa;&#10;        }&#10;&#10;        private static RSA loadUnencryptedPKCS8PrivateKey(string privateKeyContent)&#10;        {&#10;            string cleanKey = privateKeyContent&#10;                .Replace(&quot;-----BEGIN PRIVATE KEY-----&quot;, &quot;&quot;)&#10;                .Replace(&quot;-----END PRIVATE KEY-----&quot;, &quot;&quot;)&#10;                .Replace(&quot;\n&quot;, &quot;&quot;)&#10;                .Replace(&quot;\r&quot;, &quot;&quot;)&#10;                .Replace(&quot; &quot;, &quot;&quot;);&#10;&#10;            byte[] keyBytes = Convert.FromBase64String(cleanKey);&#10;&#10;            RSA rsa = RSA.Create();&#10;            rsa.ImportPkcs8PrivateKey(keyBytes, out _);&#10;            return rsa;&#10;        }&#10;&#10;        private static RSA loadPrivateKeyFromBase64(string privateKeyBase64, string password)&#10;        {&#10;            byte[] privateKeyBytes = Convert.FromBase64String(privateKeyBase64);&#10;&#10;            // Try to parse as PEM first&#10;            string pemContent = Encoding.UTF8.GetString(privateKeyBytes);&#10;            if (pemContent.Contains(&quot;-----BEGIN&quot;))&#10;            {&#10;                return loadPrivateKey(pemContent, password);&#10;            }&#10;&#10;            // Try as encrypted PKCS#8&#10;            if (!string.IsNullOrWhiteSpace(password))&#10;            {&#10;                try&#10;                {&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportEncryptedPkcs8PrivateKey(password, privateKeyBytes, out _);&#10;                    return rsa;&#10;                }&#10;                catch (Exception)&#10;                {&#10;                    // Fall through to try unencrypted&#10;                }&#10;            }&#10;&#10;            // Try as unencrypted PKCS#8&#10;            try&#10;            {&#10;                RSA rsa = RSA.Create();&#10;                rsa.ImportPkcs8PrivateKey(privateKeyBytes, out _);&#10;                return rsa;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                throw new Exception(&quot;Unable to parse private key format: &quot; + e.Message, e);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>