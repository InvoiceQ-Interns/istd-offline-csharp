<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/dto/CsrConfigDto.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/dto/CsrConfigDto.cs" />
              <option name="originalContent" value="using Newtonsoft.Json;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.DTOs&#10;{&#10;    public class CsrConfigDto&#10;    {&#10;&#10;        private string enName;&#10;&#10;        private string serialNumber;&#10;        &#10;        [JsonProperty(&quot;keySize&quot;)]&#10;        private int keySize = 2048;&#10;        &#10;        [JsonProperty(&quot;templateOid&quot;)]&#10;        private string templateOid;&#10;&#10;        [JsonProperty(&quot;major&quot;)] &#10;        private int majorVersion;&#10;&#10;        [JsonProperty(&quot;minor&quot;)] &#10;        private int minorVersion;&#10;&#10;        public CsrConfigDto() { }&#10;&#10;        public string getEnName()&#10;        {&#10;            return enName;&#10;        }&#10;&#10;        public void setEnName(string enName)&#10;        {&#10;            this.enName = enName;&#10;        }&#10;&#10;        public string getSerialNumber()&#10;        {&#10;            return serialNumber;&#10;        }&#10;&#10;        public void setSerialNumber(string serialNumber)&#10;        {&#10;            this.serialNumber = serialNumber;&#10;        }&#10;&#10;        public string getKeyPassword()&#10;        {&#10;            return keyPassword;&#10;        }&#10;&#10;        public void setKeyPassword(string keyPassword)&#10;        {&#10;            this.keyPassword = keyPassword;&#10;        }&#10;&#10;        public int getKeySize()&#10;        {&#10;            return keySize;&#10;        }&#10;&#10;        public void setKeySize(int keySize)&#10;        {&#10;            this.keySize = keySize;&#10;        }&#10;&#10;        public string getTemplateOid()&#10;        {&#10;            return templateOid;&#10;        }&#10;&#10;        public void setTemplateOid(string templateOid)&#10;        {&#10;            this.templateOid = templateOid;&#10;        }&#10;&#10;        public int getMajorVersion()&#10;        {&#10;            return majorVersion;&#10;        }&#10;&#10;        public void setMajorVersion(int majorVersion)&#10;        {&#10;            this.majorVersion = majorVersion;&#10;        }&#10;&#10;        public int getMinorVersion()&#10;        {&#10;            return minorVersion;&#10;        }&#10;&#10;        public void setMinorVersion(int minorVersion)&#10;        {&#10;            this.minorVersion = minorVersion;&#10;        }&#10;&#10;        public string getPassword()&#10;        {&#10;            return keyPassword;&#10;        }&#10;&#10;        public string getSubjectDn()&#10;        {&#10;            if (string.IsNullOrWhiteSpace(enName) || string.IsNullOrWhiteSpace(serialNumber))&#10;            {&#10;                return null;&#10;            }&#10;&#10;            return $&quot;CN={enName.Trim()}, O=Government of Jordan, OU=eID, SerialNumber={serialNumber.Trim()}, C=JO&quot;;&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using Newtonsoft.Json;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.DTOs&#10;{&#10;    public class CsrConfigDto&#10;    {&#10;&#10;        private string enName;&#10;&#10;        private string serialNumber;&#10;        &#10;        [JsonProperty(&quot;keySize&quot;)]&#10;        private int keySize = 2048;&#10;        &#10;        [JsonProperty(&quot;templateOid&quot;)]&#10;        private string templateOid;&#10;&#10;        [JsonProperty(&quot;major&quot;)] &#10;        private int majorVersion;&#10;&#10;        [JsonProperty(&quot;minor&quot;)] &#10;        private int minorVersion;&#10;&#10;        public CsrConfigDto() { }&#10;&#10;        public string getEnName()&#10;        {&#10;            return enName;&#10;        }&#10;&#10;        public void setEnName(string enName)&#10;        {&#10;            this.enName = enName;&#10;        }&#10;&#10;        public string getSerialNumber()&#10;        {&#10;            return serialNumber;&#10;        }&#10;&#10;        public void setSerialNumber(string serialNumber)&#10;        {&#10;            this.serialNumber = serialNumber;&#10;        }&#10;&#10;        public int getKeySize()&#10;        {&#10;            return keySize;&#10;        }&#10;&#10;        public void setKeySize(int keySize)&#10;        {&#10;            this.keySize = keySize;&#10;        }&#10;&#10;        public string getTemplateOid()&#10;        {&#10;            return templateOid;&#10;        }&#10;&#10;        public void setTemplateOid(string templateOid)&#10;        {&#10;            this.templateOid = templateOid;&#10;        }&#10;&#10;        public int getMajorVersion()&#10;        {&#10;            return majorVersion;&#10;        }&#10;&#10;        public void setMajorVersion(int majorVersion)&#10;        {&#10;            this.majorVersion = majorVersion;&#10;        }&#10;&#10;        public int getMinorVersion()&#10;        {&#10;            return minorVersion;&#10;        }&#10;&#10;        public void setMinorVersion(int minorVersion)&#10;        {&#10;            this.minorVersion = minorVersion;&#10;        }&#10;&#10;        public string getSubjectDn()&#10;        {&#10;            if (string.IsNullOrWhiteSpace(enName) || string.IsNullOrWhiteSpace(serialNumber))&#10;            {&#10;                return null;&#10;            }&#10;&#10;            return $&quot;CN={enName.Trim()}, O=Government of Jordan, OU=eID, SerialNumber={serialNumber.Trim()}, C=JO&quot;;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/helper/DigitalSignatureHelper.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/helper/DigitalSignatureHelper.cs" />
              <option name="originalContent" value="using System.Security.Cryptography;&#10;using ISTD_OFFLINE_CSHARP.ActionProcessor.impl;&#10;using ISTD_OFFLINE_CSHARP.DTOs;&#10;using ISTD_OFFLINE_CSHARP.utils;&#10;using Microsoft.Extensions.Logging;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.helper&#10;{&#10;    public class DigitalSignatureHelper&#10;    {&#10;        private readonly ILogger log;&#10;&#10;        public DigitalSignatureHelper()&#10;        {&#10;            this.log = LoggingUtils.getLoggerFactory().CreateLogger&lt;DigitalSignatureHelper&gt;();&#10;        }&#10;&#10;        public DigitalSignature getDigitalSignature(RSA privateKey, string invoiceHash)&#10;        {&#10;            byte[] xmlHashingBytes = Convert.FromBase64String(invoiceHash);&#10;            byte[] digitalSignatureBytes = signRSA(privateKey, xmlHashingBytes);&#10;&#10;            string digitalSignature = Convert.ToBase64String(digitalSignatureBytes);&#10;            return new DigitalSignature(digitalSignature, xmlHashingBytes);&#10;        }&#10;&#10;        private byte[] signRSA(RSA privateKey, byte[] messageHash)&#10;        {&#10;            try&#10;            {&#10;                return privateKey.SignHash(messageHash, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                log.LogError(ex, &quot;Failed to sign with RSA&quot;);&#10;                throw;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Security.Cryptography;&#10;using ISTD_OFFLINE_CSHARP.ActionProcessor.impl;&#10;using ISTD_OFFLINE_CSHARP.DTOs;&#10;using ISTD_OFFLINE_CSHARP.utils;&#10;using Microsoft.Extensions.Logging;&#10;using System.Text;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.helper&#10;{&#10;    public class DigitalSignatureHelper&#10;    {&#10;        private readonly ILogger log;&#10;&#10;        public DigitalSignatureHelper()&#10;        {&#10;            this.log = LoggingUtils.getLoggerFactory().CreateLogger&lt;DigitalSignatureHelper&gt;();&#10;        }&#10;&#10;        public DigitalSignature getDigitalSignature(RSA privateKey, string invoiceHash)&#10;        {&#10;            // Match Java exactly: decode the base64 after converting to UTF-8 bytes first&#10;            byte[] invoiceHashBytes = Encoding.UTF8.GetBytes(invoiceHash);&#10;            byte[] xmlHashingBytes = Convert.FromBase64String(Encoding.UTF8.GetString(invoiceHashBytes));&#10;            &#10;            byte[] digitalSignatureBytes = signWithPrivateKey(privateKey, xmlHashingBytes);&#10;&#10;            string digitalSignature = Convert.ToBase64String(digitalSignatureBytes);&#10;            return new DigitalSignature(digitalSignature, xmlHashingBytes);&#10;        }&#10;&#10;        private byte[] signWithPrivateKey(RSA privateKey, byte[] messageHash)&#10;        {&#10;            try&#10;            {&#10;                // Use SignData instead of SignHash to match Java's Signature.update() + sign() behavior&#10;                // This performs raw signature on the data without additional hashing&#10;                return privateKey.SignData(messageHash, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                log.LogError(ex, &quot;Failed to sign with RSA&quot;);&#10;                throw;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/helper/SigningHelper.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/helper/SigningHelper.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Globalization;&#10;using System.IO;&#10;using System.Security.Cryptography;&#10;using System.Security.Cryptography.X509Certificates;&#10;using System.Text;&#10;using System.Xml;&#10;using System.Xml.Xsl;&#10;using ISTD_OFFLINE_CSHARP.DTOs;&#10;using ISTD_OFFLINE_CSHARP.helper;&#10;using ISTD_OFFLINE_CSHARP.loader;&#10;using ISTD_OFFLINE_CSHARP.utils;&#10;using Microsoft.Extensions.Logging;&#10;using Org.BouncyCastle.Crypto.Parameters;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.Helper&#10;{&#10;    public class SigningHelper&#10;    {&#10;        private readonly ILogger&lt;SigningHelper&gt; log;&#10;        private readonly string dateTimeFormatPattern = &quot;yyyy-MM-dd'T'HH:mm:ss&quot;;&#10;        private readonly HashingHelper hashingHelper;&#10;        private readonly DigitalSignatureHelper digitalSignatureHelper;&#10;        private readonly QRGeneratorHelper qrGeneratorHelper;&#10;        private readonly AppResources appResources;&#10;&#10;        public SigningHelper()&#10;        {&#10;            log = LoggingUtils.getLoggerFactory().CreateLogger&lt;SigningHelper&gt;();&#10;            hashingHelper = new HashingHelper();&#10;            digitalSignatureHelper = new DigitalSignatureHelper();&#10;            qrGeneratorHelper = new QRGeneratorHelper();&#10;            appResources = new AppResources();&#10;        }&#10;&#10;        public EInvoiceSigningResults? signEInvoice(string xmlDocument, RSA privateKey,&#10;            string certificateAsString)&#10;        {&#10;            try&#10;            {&#10;                string invoiceHash = hashingHelper.getInvoiceHash(xmlDocument, appResources);&#10;&#10;&#10;                certificateAsString = certificateAsString&#10;                    .Replace(&quot;-----BEGIN CERTIFICATE-----&quot;, &quot;&quot;)&#10;                    .Replace(&quot;-----END CERTIFICATE-----&quot;, &quot;&quot;)&#10;                    .Replace(&quot;\n&quot;, &quot;&quot;)&#10;                    .Replace(&quot;\r&quot;, &quot;&quot;);&#10;&#10;                byte[] certificateBytes = Convert.FromBase64String(certificateAsString);&#10;                string certificateCopy = certificateAsString;&#10;&#10;&#10;                X509Certificate2 certificate = X509CertificateLoader.LoadCertificate(certificateBytes);&#10;&#10;&#10;                DigitalSignature digitalSignature = digitalSignatureHelper.getDigitalSignature(privateKey, invoiceHash);&#10;                &#10;&#10;                xmlDocument = transformXml(xmlDocument);&#10;&#10;&#10;                XmlDocument document = getXmlDocument(xmlDocument);&#10;                var nameSpacesMap = getNameSpacesMap();&#10;&#10;&#10;                string certificateHashing = encodeBase64(&#10;                    Encoding.UTF8.GetBytes(bytesToHex(hashStringToBytes(Encoding.UTF8.GetBytes(certificateAsString)))));&#10;                &#10;                Console.WriteLine(&quot;Certificate Hashing: &quot; + certificateHashing);&#10;               &#10;                string signedPropertiesHashing = populateSignedSignatureProperties(&#10;                    document, nameSpacesMap, certificateHashing, getCurrentTimestamp(),&#10;                    certificate.Issuer, certificate.SerialNumber);&#10;                &#10;                Console.WriteLine(&quot;Signed Properties Hashing: &quot; + signedPropertiesHashing);&#10;                &#10;                populateUblExtensions(document, nameSpacesMap, digitalSignature.getDigitalSignature(),&#10;                    signedPropertiesHashing, encodeBase64(digitalSignature.getXmlHashing()),&#10;                    certificateCopy);&#10;&#10;                &#10;                string qrCode = populateQrCode(document, nameSpacesMap, certificate,&#10;                    digitalSignature.getDigitalSignature(), invoiceHash);&#10;&#10;                &#10;                string uuid = readUuid(xmlDocument);&#10;&#10;                return new EInvoiceSigningResults(invoiceHash, digitalSignature.getDigitalSignature(),&#10;                    qrCode, document.OuterXml, uuid);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                log.LogError(e, &quot;Something went wrong while signing the invoice&quot;);&#10;                return null;&#10;            }&#10;        }&#10;&#10;        private static Dictionary&lt;string, string&gt; getNameSpacesMap()&#10;        {&#10;            return new Dictionary&lt;string, string&gt;&#10;            {&#10;                { &quot;&quot;, &quot;urn:oasis:names:specification:ubl:schema:xsd:Invoice-2&quot; }, // Default namespace&#10;                { &quot;cac&quot;, &quot;urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2&quot; },&#10;                { &quot;cbc&quot;, &quot;urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2&quot; },&#10;                { &quot;ext&quot;, &quot;urn:oasis:names:specification:ubl:schema:xsd:CommonExtensionComponents-2&quot; },&#10;                { &quot;sig&quot;, &quot;urn:oasis:names:specification:ubl:schema:xsd:CommonSignatureComponents-2&quot; },&#10;                { &quot;sac&quot;, &quot;urn:oasis:names:specification:ubl:schema:xsd:SignatureAggregateComponents-2&quot; },&#10;                { &quot;sbc&quot;, &quot;urn:oasis:names:specification:ubl:schema:xsd:SignatureBasicComponents-2&quot; },&#10;                { &quot;ds&quot;, &quot;http://www.w3.org/2000/09/xmldsig#&quot; },&#10;                { &quot;xades&quot;, &quot;http://uri.etsi.org/01903/v1.3.2#&quot; }&#10;            };&#10;        }&#10;&#10;        private string transformXml(string xmlDocument)&#10;        {&#10;            try&#10;            {&#10;                log.LogDebug(&quot;Starting XML transformation pipeline&quot;);&#10;&#10;&#10;                xmlDocument = transformXmlStep(xmlDocument, appResources.getRemoveElementXslTransformer(),&#10;                    &quot;removeElements&quot;);&#10;&#10;&#10;                xmlDocument = transformXmlStep(xmlDocument, appResources.getAddUBLElementTransformer(),&#10;                    &quot;addUBLElement&quot;);&#10;                xmlDocument = cleanReplaceText(xmlDocument, &quot;UBL-TO-BE-REPLACED&quot;, appResources.getUblXml());&#10;&#10;&#10;                xmlDocument = transformXmlStep(xmlDocument, appResources.getAddQRElementTransformer(), &quot;addQRElement&quot;);&#10;                xmlDocument = cleanReplaceText(xmlDocument, &quot;QR-TO-BE-REPLACED&quot;, appResources.getQrXml());&#10;&#10;&#10;                xmlDocument = transformXmlStep(xmlDocument, appResources.getAddSignatureElementTransformer(),&#10;                    &quot;addSignatureElement&quot;);&#10;                xmlDocument = cleanReplaceText(xmlDocument, &quot;SIGN-TO-BE-REPLACED&quot;, appResources.getSignatureXml());&#10;&#10;                log.LogDebug(&quot;XML transformation pipeline completed successfully&quot;);&#10;                return xmlDocument;&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                log.LogError(ex, &quot;Failed during XML transformation pipeline&quot;);&#10;                throw new InvalidOperationException(&quot;XML transformation pipeline failed&quot;, ex);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Clean replacement that handles quotes and whitespace properly&#10;        /// &lt;/summary&gt;&#10;        private static string cleanReplaceText(string xmlDocument, string placeholder, string replacement)&#10;        {&#10;            // Remove any surrounding quotes from placeholder in the XML&#10;            xmlDocument = xmlDocument.Replace($&quot;\&quot;{placeholder}\&quot;&quot;, placeholder);&#10;            xmlDocument = xmlDocument.Replace($&quot;'{placeholder}'&quot;, placeholder);&#10;            &#10;            // Perform the actual replacement&#10;            xmlDocument = xmlDocument.Replace(placeholder, replacement);&#10;            &#10;            return xmlDocument;&#10;        }&#10;&#10;        private string transformXmlStep(string xmlDocument, XslCompiledTransform transformer,&#10;            string stepName = &quot;unknown&quot;)&#10;        {&#10;            try&#10;            {&#10;                &#10;                xmlDocument = cleanXmlDocument(xmlDocument);&#10;&#10;                using var inputStream = new StringReader(xmlDocument);&#10;                using var outputStream = new StringWriter();&#10;&#10;                &#10;                var readerSettings = new XmlReaderSettings&#10;                {&#10;                    DtdProcessing = DtdProcessing.Prohibit,&#10;                    XmlResolver = null,&#10;                    NameTable = new NameTable(),&#10;                    CheckCharacters = false &#10;                };&#10;&#10;                using var xmlReader = XmlReader.Create(inputStream, readerSettings);&#10;&#10;                &#10;                var xsltArgs = new XsltArgumentList();&#10;&#10;                transformer.Transform(xmlReader, xsltArgs, outputStream);&#10;&#10;                return outputStream.ToString();&#10;            }&#10;            catch (XmlException ex)&#10;            {&#10;                log.LogError(ex,&#10;                    &quot;XML transformation failed in step '{StepName}' at line {LineNumber}, position {LinePosition}: {Message}&quot;,&#10;                    stepName, ex.LineNumber, ex.LinePosition, ex.Message);&#10;                throw new InvalidOperationException(&#10;                    $&quot;XML transformation failed in step '{stepName}' at line {ex.LineNumber}, position {ex.LinePosition}: {ex.Message}&quot;,&#10;                    ex);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                log.LogError(ex, &quot;Transformation failed in step '{StepName}': {Message}&quot;, stepName, ex.Message);&#10;                throw new InvalidOperationException($&quot;Transformation failed in step '{stepName}': {ex.Message}&quot;, ex);&#10;            }&#10;        }&#10;&#10;        private static string cleanXmlDocument(string xmlDocument)&#10;        {&#10;            if (string.IsNullOrWhiteSpace(xmlDocument))&#10;                return xmlDocument;&#10;&#10;            &#10;            xmlDocument = xmlDocument.Trim('\uFEFF', '\u200B', '\0');&#10;&#10;            &#10;            xmlDocument = xmlDocument.TrimStart();&#10;&#10;            &#10;            if (!xmlDocument.StartsWith(&quot;&lt;?xml&quot;, StringComparison.OrdinalIgnoreCase))&#10;            {&#10;                // Add XML declaration if missing&#10;                xmlDocument = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot; + xmlDocument;&#10;            }&#10;&#10;            &#10;            xmlDocument = fixNamespaceDeclarations(xmlDocument);&#10;&#10;            return xmlDocument;&#10;        }&#10;&#10;        private static string fixNamespaceDeclarations(string xmlDocument)&#10;        {&#10;            &#10;            xmlDocument = System.Text.RegularExpressions.Regex.Replace(&#10;                xmlDocument,&#10;                @&quot;\s+xmlns\s*=\s*[&quot;&quot;'][\s]*[&quot;&quot;']&quot;,&#10;                &quot;&quot;,&#10;                System.Text.RegularExpressions.RegexOptions.IgnoreCase);&#10;&#10;          &#10;            xmlDocument = System.Text.RegularExpressions.Regex.Replace(&#10;                xmlDocument,&#10;                @&quot;\s+xmlns:([^=\s]+)\s*=\s*[&quot;&quot;'][\s]*[&quot;&quot;']&quot;,&#10;                &quot;&quot;,&#10;                System.Text.RegularExpressions.RegexOptions.IgnoreCase);&#10;&#10;            return xmlDocument;&#10;        }&#10;&#10;        private static XmlDocument getXmlDocument(string xmlDocument)&#10;        {&#10;            try&#10;            {&#10;                var doc = new XmlDocument();&#10;                var settings = new XmlReaderSettings&#10;                {&#10;                    DtdProcessing = DtdProcessing.Prohibit,&#10;                    XmlResolver = null,&#10;                    CheckCharacters = false,&#10;                    IgnoreWhitespace = false&#10;                };&#10;&#10;                using var stringReader = new StringReader(xmlDocument);&#10;                using var xmlReader = XmlReader.Create(stringReader, settings);&#10;                doc.Load(xmlReader);&#10;                return doc;&#10;            }&#10;            catch (XmlException ex)&#10;            {&#10;                throw new XmlException($&quot;Failed to parse XML document: {ex.Message}&quot;, ex);&#10;            }&#10;        }&#10;&#10;        private static string? getNodeXmlValue(XmlDocument document, Dictionary&lt;string, string&gt; nameSpaces)&#10;        {&#10;            var namespaceManager = new XmlNamespaceManager(document.NameTable);&#10;&#10;&#10;            foreach (var ns in nameSpaces)&#10;            {&#10;                if (string.IsNullOrEmpty(ns.Key))&#10;                {&#10;                    namespaceManager.AddNamespace(&quot;def&quot;, ns.Value); // Use 'def' for default namespace&#10;                }&#10;                else&#10;                {&#10;                    namespaceManager.AddNamespace(ns.Key, ns.Value);&#10;                }&#10;            }&#10;&#10;            const string xpath =&#10;                &quot;/def:Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:Object/xades:QualifyingProperties/xades:SignedProperties&quot;;&#10;            XmlNode? node = document.SelectSingleNode(xpath, namespaceManager);&#10;            return node?.OuterXml;&#10;        }&#10;&#10;        private static string bytesToHex(byte[] hash)&#10;        {&#10;            StringBuilder hexString = new StringBuilder(2 * hash.Length);&#10;            foreach (byte b in hash)&#10;            {&#10;                string hex = (b &amp; 0xFF).ToString(&quot;x2&quot;);&#10;                hexString.Append(hex);&#10;            }&#10;&#10;            return hexString.ToString();&#10;        }&#10;&#10;        private static string encodeBase64(byte[] stringToBeEncoded)&#10;        {&#10;            return Convert.ToBase64String(stringToBeEncoded);&#10;        }&#10;&#10;        private static byte[] hashStringToBytes(byte[] toBeHashed)&#10;        {&#10;            using var sha256 = SHA256.Create();&#10;            return sha256.ComputeHash(toBeHashed);&#10;        }&#10;&#10;        private string populateSignedSignatureProperties(XmlDocument document,&#10;            Dictionary&lt;string, string&gt; nameSpacesMap,&#10;            string publicKeyHashing, string signatureTimestamp, string x509IssuerName, string serialNumber)&#10;        {&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:Object/xades:QualifyingProperties/xades:SignedProperties/xades:SignedSignatureProperties/xades:SigningCertificate/xades:Cert/xades:CertDigest/ds:DigestValue&quot;,&#10;                publicKeyHashing);&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:Object/xades:QualifyingProperties/xades:SignedProperties/xades:SignedSignatureProperties/xades:SigningTime&quot;,&#10;                signatureTimestamp);&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:Object/xades:QualifyingProperties/xades:SignedProperties/xades:SignedSignatureProperties/xades:SigningCertificate/xades:Cert/xades:IssuerSerial/ds:X509IssuerName&quot;,&#10;                x509IssuerName);&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:Object/xades:QualifyingProperties/xades:SignedProperties/xades:SignedSignatureProperties/xades:SigningCertificate/xades:Cert/xades:IssuerSerial/ds:X509SerialNumber&quot;,&#10;                serialNumber);&#10;&#10;            string? signedSignatureElement = getNodeXmlValue(document, nameSpacesMap);&#10;&#10;            if (!string.IsNullOrEmpty(signedSignatureElement))&#10;            {&#10;                return encodeBase64(&#10;                    Encoding.UTF8.GetBytes(&#10;                        bytesToHex(hashStringToBytes(Encoding.UTF8.GetBytes(signedSignatureElement)))));&#10;            }&#10;&#10;            return string.Empty;&#10;        }&#10;&#10;        private static void populateXmlAttributeValue(XmlDocument document,&#10;           Dictionary&lt;string, string&gt; nameSpaces,&#10;            string attributeXpath, string newValue)&#10;        {&#10;            var namespaceManager = new XmlNamespaceManager(document.NameTable);&#10;&#10;           &#10;            foreach (var ns in nameSpaces)&#10;            {&#10;                if (string.IsNullOrEmpty(ns.Key))&#10;                {&#10;                    namespaceManager.AddNamespace(&quot;def&quot;, ns.Value); // Use 'def' for default namespace&#10;                }&#10;                else&#10;                {&#10;                    namespaceManager.AddNamespace(ns.Key, ns.Value);&#10;                }&#10;            }&#10;&#10;            // Replace /Invoice with /def:Invoice in xpath if it starts with /Invoice&#10;            if (attributeXpath.StartsWith(&quot;/Invoice/&quot;))&#10;            {&#10;                attributeXpath = attributeXpath.Replace(&quot;/Invoice/&quot;, &quot;/def:Invoice/&quot;);&#10;            }&#10;&#10;            XmlNodeList? nodes = document.SelectNodes(attributeXpath, namespaceManager);&#10;            if (nodes != null)&#10;            {&#10;                foreach (XmlNode node in nodes)&#10;                {&#10;                    if (node is XmlElement element)&#10;                    {&#10;                        element.InnerText = newValue;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void populateUblExtensions(XmlDocument document,&#10;            Dictionary&lt;string, string&gt; nameSpacesMap,&#10;            string digitalSignature, string signedPropertiesHashing, string xmlHashing, string certificate)&#10;        {&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:SignatureValue&quot;,&#10;                digitalSignature);&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:KeyInfo/ds:X509Data/ds:X509Certificate&quot;,&#10;                certificate);&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:SignedInfo/ds:Reference[@URI='#xadesSignedProperties']/ds:DigestValue&quot;,&#10;                signedPropertiesHashing);&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:SignedInfo/ds:Reference[@Id='invoiceSignedData']/ds:DigestValue&quot;,&#10;                xmlHashing);&#10;        }&#10;&#10;        private string getCurrentTimestamp()&#10;        {&#10;            return DateTime.Now.ToString(dateTimeFormatPattern, CultureInfo.InvariantCulture);&#10;        }&#10;&#10;        private string populateQrCode(XmlDocument document,&#10;            Dictionary&lt;string, string&gt; nameSpacesMap,&#10;            X509Certificate2 certificate, string signature, string hashedXml)&#10;        {&#10;            string? sellerName = getNodeXmlTextValue(document, nameSpacesMap,&#10;                &quot;/Invoice/cac:AccountingSupplierParty/cac:Party/cac:PartyLegalEntity/cbc:RegistrationName&quot;);&#10;            string? vatRegistrationNumber = getNodeXmlTextValue(document, nameSpacesMap,&#10;                &quot;/Invoice/cac:AccountingSupplierParty/cac:Party/cac:PartyTaxScheme/cbc:CompanyID&quot;);&#10;            string? invoiceTotal = getNodeXmlTextValue(document, nameSpacesMap,&#10;                &quot;/Invoice/cac:LegalMonetaryTotal/cbc:PayableAmount&quot;);&#10;            string? vatTotal = getNodeXmlTextValue(document, nameSpacesMap,&#10;                &quot;/Invoice/cac:TaxTotal/cbc:TaxAmount&quot;);&#10;            string? issueDate = getNodeXmlTextValue(document, nameSpacesMap, &quot;/Invoice/cbc:IssueDate&quot;);&#10;            string? issueTime = getNodeXmlTextValue(document, nameSpacesMap, &quot;/Invoice/cbc:IssueTime&quot;);&#10;&#10;            if (string.IsNullOrEmpty(issueTime))&#10;            {&#10;                issueTime = &quot;00:00:00&quot;;&#10;                log.LogWarning(&quot;IssueTime element missing from invoice, using default time: {IssueTime}&quot;, issueTime);&#10;            }&#10;&#10;            string timeStamp = processDateTime(issueDate ?? &quot;&quot;, issueTime);&#10;&#10;            string qrCode = qrGeneratorHelper.generateQrCode(&#10;                sellerName ?? &quot;&quot;,&#10;                vatRegistrationNumber ?? &quot;&quot;,&#10;                timeStamp,&#10;                invoiceTotal ?? &quot;&quot;,&#10;                vatTotal ?? &quot;&quot;,&#10;                hashedXml,&#10;                certificate.GetPublicKey(),&#10;                signature,&#10;                certificate.GetRawCertData());&#10;&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/cac:AdditionalDocumentReference[cbc:ID='QR']/cac:Attachment/cbc:EmbeddedDocumentBinaryObject&quot;,&#10;                qrCode);&#10;&#10;            return qrCode;&#10;        }&#10;&#10;        private string processDateTime(string issueDate, string issueTime)&#10;        {&#10;            if (issueTime.EndsWith('Z'))&#10;            {&#10;                issueTime = issueTime.Replace(&quot;Z&quot;, &quot;&quot;);&#10;                string dateTimeString = $&quot;{issueDate}T{issueTime}&quot;;&#10;&#10;                if (DateTime.TryParseExact(dateTimeString, &quot;yyyy-MM-ddTHH:mm:ss&quot;,&#10;                        CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal, out DateTime utcDateTime))&#10;                {&#10;                    // Convert from UTC to GMT+3&#10;                    DateTime ksaTime = utcDateTime.AddHours(3);&#10;                    return ksaTime.ToString(dateTimeFormatPattern, CultureInfo.InvariantCulture);&#10;                }&#10;            }&#10;&#10;            string stringDateTime = $&quot;{issueDate}T{issueTime}&quot;;&#10;            if (DateTime.TryParseExact(stringDateTime, &quot;yyyy-MM-ddTHH:mm:ss&quot;,&#10;                    CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime dateTime))&#10;            {&#10;                return dateTime.ToString(dateTimeFormatPattern, CultureInfo.InvariantCulture);&#10;            }&#10;&#10;            return stringDateTime;&#10;        }&#10;&#10;        private string? getNodeXmlTextValue(XmlDocument document,&#10;            Dictionary&lt;string, string&gt; nameSpaces, string attributeXpath)&#10;        {&#10;            var namespaceManager = new XmlNamespaceManager(document.NameTable);&#10;&#10;            &#10;            foreach (var ns in nameSpaces)&#10;            {&#10;                if (string.IsNullOrEmpty(ns.Key))&#10;                {&#10;                    namespaceManager.AddNamespace(&quot;def&quot;, ns.Value); // Use 'def' for default namespace&#10;                }&#10;                else&#10;                {&#10;                    namespaceManager.AddNamespace(ns.Key, ns.Value);&#10;                }&#10;            }&#10;&#10;            // Replace /Invoice with /def:Invoice in xpath if it starts with /Invoice&#10;            if (attributeXpath.StartsWith(&quot;/Invoice/&quot;))&#10;            {&#10;                attributeXpath = attributeXpath.Replace(&quot;/Invoice/&quot;, &quot;/def:Invoice/&quot;);&#10;            }&#10;&#10;            XmlNode? node = document.SelectSingleNode(attributeXpath, namespaceManager);&#10;            if (node == null)&#10;            {&#10;                log.LogDebug(&quot;XML node not found for path: {AttributeXpath}&quot;, attributeXpath);&#10;                return null;&#10;            }&#10;&#10;            return node.InnerText;&#10;        }&#10;&#10;        public string readUuid(string xmlDocument)&#10;        {&#10;            try&#10;            {&#10;                XmlDocument document = getXmlDocument(xmlDocument);&#10;                var nameSpaces = getNameSpacesMap();&#10;&#10;&#10;                string? uuid = getNodeXmlTextValue(document, nameSpaces, &quot;/Invoice/cbc:UUID&quot;);&#10;&#10;                if (string.IsNullOrEmpty(uuid))&#10;                {&#10;                    log.LogWarning(&quot;UUID not found in invoice document&quot;);&#10;                    return string.Empty;&#10;                }&#10;&#10;                return uuid;&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                log.LogError(ex, &quot;Failed to read UUID from XML document&quot;);&#10;                throw;&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Globalization;&#10;using System.IO;&#10;using System.Linq;&#10;using System.Security.Cryptography;&#10;using System.Security.Cryptography.X509Certificates;&#10;using System.Text;&#10;using System.Xml;&#10;using System.Xml.Xsl;&#10;using ISTD_OFFLINE_CSHARP.DTOs;&#10;using ISTD_OFFLINE_CSHARP.helper;&#10;using ISTD_OFFLINE_CSHARP.loader;&#10;using ISTD_OFFLINE_CSHARP.utils;&#10;using Microsoft.Extensions.Logging;&#10;using Org.BouncyCastle.Crypto.Parameters;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.Helper&#10;{&#10;    public class SigningHelper&#10;    {&#10;        private readonly ILogger&lt;SigningHelper&gt; log;&#10;        private readonly string dateTimeFormatPattern = &quot;yyyy-MM-dd'T'HH:mm:ss&quot;;&#10;        private readonly HashingHelper hashingHelper;&#10;        private readonly DigitalSignatureHelper digitalSignatureHelper;&#10;        private readonly QRGeneratorHelper qrGeneratorHelper;&#10;        private readonly AppResources appResources;&#10;&#10;        public SigningHelper()&#10;        {&#10;            log = LoggingUtils.getLoggerFactory().CreateLogger&lt;SigningHelper&gt;();&#10;            hashingHelper = new HashingHelper();&#10;            digitalSignatureHelper = new DigitalSignatureHelper();&#10;            qrGeneratorHelper = new QRGeneratorHelper();&#10;            appResources = new AppResources();&#10;        }&#10;&#10;        public EInvoiceSigningResults? signEInvoice(string xmlDocument, RSA privateKey,&#10;            string certificateAsString)&#10;        {&#10;            try&#10;            {&#10;                string invoiceHash = hashingHelper.getInvoiceHash(xmlDocument, appResources);&#10;&#10;&#10;                certificateAsString = certificateAsString&#10;                    .Replace(&quot;-----BEGIN CERTIFICATE-----&quot;, &quot;&quot;)&#10;                    .Replace(&quot;-----END CERTIFICATE-----&quot;, &quot;&quot;)&#10;                    .Replace(&quot;\n&quot;, &quot;&quot;)&#10;                    .Replace(&quot;\r&quot;, &quot;&quot;);&#10;&#10;                byte[] certificateBytes = Convert.FromBase64String(certificateAsString);&#10;                string certificateCopy = certificateAsString;&#10;&#10;&#10;                X509Certificate2 certificate = X509CertificateLoader.LoadCertificate(certificateBytes);&#10;&#10;&#10;                DigitalSignature digitalSignature = digitalSignatureHelper.getDigitalSignature(privateKey, invoiceHash);&#10;                &#10;&#10;                xmlDocument = transformXml(xmlDocument);&#10;&#10;&#10;                XmlDocument document = getXmlDocument(xmlDocument);&#10;                var nameSpacesMap = getNameSpacesMap();&#10;&#10;&#10;                string certificateHashing = encodeBase64(&#10;                    Encoding.UTF8.GetBytes(bytesToHex(hashStringToBytes(Encoding.UTF8.GetBytes(certificateAsString)))));&#10;                &#10;                Console.WriteLine(&quot;Certificate Hashing: &quot; + certificateHashing);&#10;&#10;                // Convert certificate serial number to base 10 format&#10;                string serialNumberBase10 = convertSerialNumberToBase10(certificate.SerialNumber);&#10;               &#10;                string signedPropertiesHashing = populateSignedSignatureProperties(&#10;                    document, nameSpacesMap, certificateHashing, getCurrentTimestamp(),&#10;                    certificate.Issuer, serialNumberBase10);&#10;                &#10;                Console.WriteLine(&quot;Signed Properties Hashing: &quot; + signedPropertiesHashing);&#10;                &#10;                populateUblExtensions(document, nameSpacesMap, digitalSignature.getDigitalSignature(),&#10;                    signedPropertiesHashing, encodeBase64(digitalSignature.getXmlHashing()),&#10;                    certificateCopy);&#10;&#10;                &#10;                string qrCode = populateQrCode(document, nameSpacesMap, certificate,&#10;                    digitalSignature.getDigitalSignature(), invoiceHash);&#10;&#10;                &#10;                string uuid = readUuid(xmlDocument);&#10;&#10;                return new EInvoiceSigningResults(invoiceHash, digitalSignature.getDigitalSignature(),&#10;                    qrCode, document.OuterXml, uuid);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                log.LogError(e, &quot;Something went wrong while signing the invoice&quot;);&#10;                return null;&#10;            }&#10;        }&#10;&#10;        private static Dictionary&lt;string, string&gt; getNameSpacesMap()&#10;        {&#10;            return new Dictionary&lt;string, string&gt;&#10;            {&#10;                { &quot;&quot;, &quot;urn:oasis:names:specification:ubl:schema:xsd:Invoice-2&quot; }, // Default namespace&#10;                { &quot;cac&quot;, &quot;urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2&quot; },&#10;                { &quot;cbc&quot;, &quot;urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2&quot; },&#10;                { &quot;ext&quot;, &quot;urn:oasis:names:specification:ubl:schema:xsd:CommonExtensionComponents-2&quot; },&#10;                { &quot;sig&quot;, &quot;urn:oasis:names:specification:ubl:schema:xsd:CommonSignatureComponents-2&quot; },&#10;                { &quot;sac&quot;, &quot;urn:oasis:names:specification:ubl:schema:xsd:SignatureAggregateComponents-2&quot; },&#10;                { &quot;sbc&quot;, &quot;urn:oasis:names:specification:ubl:schema:xsd:SignatureBasicComponents-2&quot; },&#10;                { &quot;ds&quot;, &quot;http://www.w3.org/2000/09/xmldsig#&quot; },&#10;                { &quot;xades&quot;, &quot;http://uri.etsi.org/01903/v1.3.2#&quot; }&#10;            };&#10;        }&#10;&#10;        private string transformXml(string xmlDocument)&#10;        {&#10;            try&#10;            {&#10;                log.LogDebug(&quot;Starting XML transformation pipeline&quot;);&#10;&#10;&#10;                xmlDocument = transformXmlStep(xmlDocument, appResources.getRemoveElementXslTransformer(),&#10;                    &quot;removeElements&quot;);&#10;&#10;&#10;                xmlDocument = transformXmlStep(xmlDocument, appResources.getAddUBLElementTransformer(),&#10;                    &quot;addUBLElement&quot;);&#10;                xmlDocument = cleanReplaceText(xmlDocument, &quot;UBL-TO-BE-REPLACED&quot;, appResources.getUblXml());&#10;&#10;&#10;                xmlDocument = transformXmlStep(xmlDocument, appResources.getAddQRElementTransformer(), &quot;addQRElement&quot;);&#10;                xmlDocument = cleanReplaceText(xmlDocument, &quot;QR-TO-BE-REPLACED&quot;, appResources.getQrXml());&#10;&#10;&#10;                xmlDocument = transformXmlStep(xmlDocument, appResources.getAddSignatureElementTransformer(),&#10;                    &quot;addSignatureElement&quot;);&#10;                xmlDocument = cleanReplaceText(xmlDocument, &quot;SIGN-TO-BE-REPLACED&quot;, appResources.getSignatureXml());&#10;&#10;                log.LogDebug(&quot;XML transformation pipeline completed successfully&quot;);&#10;                return xmlDocument;&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                log.LogError(ex, &quot;Failed during XML transformation pipeline&quot;);&#10;                throw new InvalidOperationException(&quot;XML transformation pipeline failed&quot;, ex);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Clean replacement that handles quotes and whitespace properly&#10;        /// &lt;/summary&gt;&#10;        private static string cleanReplaceText(string xmlDocument, string placeholder, string replacement)&#10;        {&#10;            // Remove any surrounding quotes from placeholder in the XML&#10;            xmlDocument = xmlDocument.Replace($&quot;\&quot;{placeholder}\&quot;&quot;, placeholder);&#10;            xmlDocument = xmlDocument.Replace($&quot;'{placeholder}'&quot;, placeholder);&#10;            &#10;            // Perform the actual replacement&#10;            xmlDocument = xmlDocument.Replace(placeholder, replacement);&#10;            &#10;            return xmlDocument;&#10;        }&#10;&#10;        private string transformXmlStep(string xmlDocument, XslCompiledTransform transformer,&#10;            string stepName = &quot;unknown&quot;)&#10;        {&#10;            try&#10;            {&#10;                &#10;                xmlDocument = cleanXmlDocument(xmlDocument);&#10;&#10;                using var inputStream = new StringReader(xmlDocument);&#10;                using var outputStream = new StringWriter();&#10;&#10;                &#10;                var readerSettings = new XmlReaderSettings&#10;                {&#10;                    DtdProcessing = DtdProcessing.Prohibit,&#10;                    XmlResolver = null,&#10;                    NameTable = new NameTable(),&#10;                    CheckCharacters = false &#10;                };&#10;&#10;                using var xmlReader = XmlReader.Create(inputStream, readerSettings);&#10;&#10;                &#10;                var xsltArgs = new XsltArgumentList();&#10;&#10;                transformer.Transform(xmlReader, xsltArgs, outputStream);&#10;&#10;                return outputStream.ToString();&#10;            }&#10;            catch (XmlException ex)&#10;            {&#10;                log.LogError(ex,&#10;                    &quot;XML transformation failed in step '{StepName}' at line {LineNumber}, position {LinePosition}: {Message}&quot;,&#10;                    stepName, ex.LineNumber, ex.LinePosition, ex.Message);&#10;                throw new InvalidOperationException(&#10;                    $&quot;XML transformation failed in step '{stepName}' at line {ex.LineNumber}, position {ex.LinePosition}: {ex.Message}&quot;,&#10;                    ex);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                log.LogError(ex, &quot;Transformation failed in step '{StepName}': {Message}&quot;, stepName, ex.Message);&#10;                throw new InvalidOperationException($&quot;Transformation failed in step '{stepName}': {ex.Message}&quot;, ex);&#10;            }&#10;        }&#10;&#10;        private static string cleanXmlDocument(string xmlDocument)&#10;        {&#10;            if (string.IsNullOrWhiteSpace(xmlDocument))&#10;                return xmlDocument;&#10;&#10;            &#10;            xmlDocument = xmlDocument.Trim('\uFEFF', '\u200B', '\0');&#10;&#10;            &#10;            xmlDocument = xmlDocument.TrimStart();&#10;&#10;            &#10;            if (!xmlDocument.StartsWith(&quot;&lt;?xml&quot;, StringComparison.OrdinalIgnoreCase))&#10;            {&#10;                // Add XML declaration if missing&#10;                xmlDocument = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot; + xmlDocument;&#10;            }&#10;&#10;            &#10;            xmlDocument = fixNamespaceDeclarations(xmlDocument);&#10;&#10;            return xmlDocument;&#10;        }&#10;&#10;        private static string fixNamespaceDeclarations(string xmlDocument)&#10;        {&#10;            &#10;            xmlDocument = System.Text.RegularExpressions.Regex.Replace(&#10;                xmlDocument,&#10;                @&quot;\s+xmlns\s*=\s*[&quot;&quot;'][\s]*[&quot;&quot;']&quot;,&#10;                &quot;&quot;,&#10;                System.Text.RegularExpressions.RegexOptions.IgnoreCase);&#10;&#10;          &#10;            xmlDocument = System.Text.RegularExpressions.Regex.Replace(&#10;                xmlDocument,&#10;                @&quot;\s+xmlns:([^=\s]+)\s*=\s*[&quot;&quot;'][\s]*[&quot;&quot;']&quot;,&#10;                &quot;&quot;,&#10;                System.Text.RegularExpressions.RegexOptions.IgnoreCase);&#10;&#10;            return xmlDocument;&#10;        }&#10;&#10;        private static XmlDocument getXmlDocument(string xmlDocument)&#10;        {&#10;            try&#10;            {&#10;                var doc = new XmlDocument();&#10;                var settings = new XmlReaderSettings&#10;                {&#10;                    DtdProcessing = DtdProcessing.Prohibit,&#10;                    XmlResolver = null,&#10;                    CheckCharacters = false,&#10;                    IgnoreWhitespace = false&#10;                };&#10;&#10;                using var stringReader = new StringReader(xmlDocument);&#10;                using var xmlReader = XmlReader.Create(stringReader, settings);&#10;                doc.Load(xmlReader);&#10;                return doc;&#10;            }&#10;            catch (XmlException ex)&#10;            {&#10;                throw new XmlException($&quot;Failed to parse XML document: {ex.Message}&quot;, ex);&#10;            }&#10;        }&#10;&#10;        private static string? getNodeXmlValue(XmlDocument document, Dictionary&lt;string, string&gt; nameSpaces)&#10;        {&#10;            var namespaceManager = new XmlNamespaceManager(document.NameTable);&#10;&#10;&#10;            foreach (var ns in nameSpaces)&#10;            {&#10;                if (string.IsNullOrEmpty(ns.Key))&#10;                {&#10;                    namespaceManager.AddNamespace(&quot;def&quot;, ns.Value); // Use 'def' for default namespace&#10;                }&#10;                else&#10;                {&#10;                    namespaceManager.AddNamespace(ns.Key, ns.Value);&#10;                }&#10;            }&#10;&#10;            const string xpath =&#10;                &quot;/def:Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:Object/xades:QualifyingProperties/xades:SignedProperties&quot;;&#10;            XmlNode? node = document.SelectSingleNode(xpath, namespaceManager);&#10;            return node?.OuterXml;&#10;        }&#10;&#10;        private static string bytesToHex(byte[] hash)&#10;        {&#10;            StringBuilder hexString = new StringBuilder(2 * hash.Length);&#10;            foreach (byte b in hash)&#10;            {&#10;                string hex = (b &amp; 0xFF).ToString(&quot;x2&quot;);&#10;                hexString.Append(hex);&#10;            }&#10;&#10;            return hexString.ToString();&#10;        }&#10;&#10;        private static string encodeBase64(byte[] stringToBeEncoded)&#10;        {&#10;            return Convert.ToBase64String(stringToBeEncoded);&#10;        }&#10;&#10;        private static byte[] hashStringToBytes(byte[] toBeHashed)&#10;        {&#10;            using var sha256 = SHA256.Create();&#10;            return sha256.ComputeHash(toBeHashed);&#10;        }&#10;&#10;        private string populateSignedSignatureProperties(XmlDocument document,&#10;            Dictionary&lt;string, string&gt; nameSpacesMap,&#10;            string publicKeyHashing, string signatureTimestamp, string x509IssuerName, string serialNumber)&#10;        {&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:Object/xades:QualifyingProperties/xades:SignedProperties/xades:SignedSignatureProperties/xades:SigningCertificate/xades:Cert/xades:CertDigest/ds:DigestValue&quot;,&#10;                publicKeyHashing);&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:Object/xades:QualifyingProperties/xades:SignedProperties/xades:SignedSignatureProperties/xades:SigningTime&quot;,&#10;                signatureTimestamp);&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:Object/xades:QualifyingProperties/xades:SignedProperties/xades:SignedSignatureProperties/xades:SigningCertificate/xades:Cert/xades:IssuerSerial/ds:X509IssuerName&quot;,&#10;                x509IssuerName);&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:Object/xades:QualifyingProperties/xades:SignedProperties/xades:SignedSignatureProperties/xades:SigningCertificate/xades:Cert/xades:IssuerSerial/ds:X509SerialNumber&quot;,&#10;                serialNumber);&#10;&#10;            string? signedSignatureElement = getNodeXmlValue(document, nameSpacesMap);&#10;&#10;            if (!string.IsNullOrEmpty(signedSignatureElement))&#10;            {&#10;                return encodeBase64(&#10;                    Encoding.UTF8.GetBytes(&#10;                        bytesToHex(hashStringToBytes(Encoding.UTF8.GetBytes(signedSignatureElement)))));&#10;            }&#10;&#10;            return string.Empty;&#10;        }&#10;&#10;        private static void populateXmlAttributeValue(XmlDocument document,&#10;           Dictionary&lt;string, string&gt; nameSpaces,&#10;            string attributeXpath, string newValue)&#10;        {&#10;            var namespaceManager = new XmlNamespaceManager(document.NameTable);&#10;&#10;           &#10;            foreach (var ns in nameSpaces)&#10;            {&#10;                if (string.IsNullOrEmpty(ns.Key))&#10;                {&#10;                    namespaceManager.AddNamespace(&quot;def&quot;, ns.Value); // Use 'def' for default namespace&#10;                }&#10;                else&#10;                {&#10;                    namespaceManager.AddNamespace(ns.Key, ns.Value);&#10;                }&#10;            }&#10;&#10;            // Replace /Invoice with /def:Invoice in xpath if it starts with /Invoice&#10;            if (attributeXpath.StartsWith(&quot;/Invoice/&quot;))&#10;            {&#10;                attributeXpath = attributeXpath.Replace(&quot;/Invoice/&quot;, &quot;/def:Invoice/&quot;);&#10;            }&#10;&#10;            XmlNodeList? nodes = document.SelectNodes(attributeXpath, namespaceManager);&#10;            if (nodes != null)&#10;            {&#10;                foreach (XmlNode node in nodes)&#10;                {&#10;                    if (node is XmlElement element)&#10;                    {&#10;                        element.InnerText = newValue;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void populateUblExtensions(XmlDocument document,&#10;            Dictionary&lt;string, string&gt; nameSpacesMap,&#10;            string digitalSignature, string signedPropertiesHashing, string xmlHashing, string certificate)&#10;        {&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:SignatureValue&quot;,&#10;                digitalSignature);&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:KeyInfo/ds:X509Data/ds:X509Certificate&quot;,&#10;                certificate);&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:SignedInfo/ds:Reference[@URI='#xadesSignedProperties']/ds:DigestValue&quot;,&#10;                signedPropertiesHashing);&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/ext:UBLExtensions/ext:UBLExtension/ext:ExtensionContent/sig:UBLDocumentSignatures/sac:SignatureInformation/ds:Signature/ds:SignedInfo/ds:Reference[@Id='invoiceSignedData']/ds:DigestValue&quot;,&#10;                xmlHashing);&#10;        }&#10;&#10;        private string getCurrentTimestamp()&#10;        {&#10;            return DateTime.Now.ToString(dateTimeFormatPattern, CultureInfo.InvariantCulture);&#10;        }&#10;&#10;        private string populateQrCode(XmlDocument document,&#10;            Dictionary&lt;string, string&gt; nameSpacesMap,&#10;            X509Certificate2 certificate, string signature, string hashedXml)&#10;        {&#10;            string? sellerName = getNodeXmlTextValue(document, nameSpacesMap,&#10;                &quot;/Invoice/cac:AccountingSupplierParty/cac:Party/cac:PartyLegalEntity/cbc:RegistrationName&quot;);&#10;            string? vatRegistrationNumber = getNodeXmlTextValue(document, nameSpacesMap,&#10;                &quot;/Invoice/cac:AccountingSupplierParty/cac:Party/cac:PartyTaxScheme/cbc:CompanyID&quot;);&#10;            string? invoiceTotal = getNodeXmlTextValue(document, nameSpacesMap,&#10;                &quot;/Invoice/cac:LegalMonetaryTotal/cbc:PayableAmount&quot;);&#10;            string? vatTotal = getNodeXmlTextValue(document, nameSpacesMap,&#10;                &quot;/Invoice/cac:TaxTotal/cbc:TaxAmount&quot;);&#10;            string? issueDate = getNodeXmlTextValue(document, nameSpacesMap, &quot;/Invoice/cbc:IssueDate&quot;);&#10;            string? issueTime = getNodeXmlTextValue(document, nameSpacesMap, &quot;/Invoice/cbc:IssueTime&quot;);&#10;&#10;            if (string.IsNullOrEmpty(issueTime))&#10;            {&#10;                issueTime = &quot;00:00:00&quot;;&#10;                log.LogWarning(&quot;IssueTime element missing from invoice, using default time: {IssueTime}&quot;, issueTime);&#10;            }&#10;&#10;            string timeStamp = processDateTime(issueDate ?? &quot;&quot;, issueTime);&#10;&#10;            string qrCode = qrGeneratorHelper.generateQrCode(&#10;                sellerName ?? &quot;&quot;,&#10;                vatRegistrationNumber ?? &quot;&quot;,&#10;                timeStamp,&#10;                invoiceTotal ?? &quot;&quot;,&#10;                vatTotal ?? &quot;&quot;,&#10;                hashedXml,&#10;                certificate.GetPublicKey(),&#10;                signature,&#10;                certificate.GetRawCertData());&#10;&#10;            populateXmlAttributeValue(document, nameSpacesMap,&#10;                &quot;/Invoice/cac:AdditionalDocumentReference[cbc:ID='QR']/cac:Attachment/cbc:EmbeddedDocumentBinaryObject&quot;,&#10;                qrCode);&#10;&#10;            return qrCode;&#10;        }&#10;&#10;        private string processDateTime(string issueDate, string issueTime)&#10;        {&#10;            if (issueTime.EndsWith('Z'))&#10;            {&#10;                issueTime = issueTime.Replace(&quot;Z&quot;, &quot;&quot;);&#10;                string dateTimeString = $&quot;{issueDate}T{issueTime}&quot;;&#10;&#10;                if (DateTime.TryParseExact(dateTimeString, &quot;yyyy-MM-ddTHH:mm:ss&quot;,&#10;                        CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal, out DateTime utcDateTime))&#10;                {&#10;                    // Convert from UTC to GMT+3&#10;                    DateTime ksaTime = utcDateTime.AddHours(3);&#10;                    return ksaTime.ToString(dateTimeFormatPattern, CultureInfo.InvariantCulture);&#10;                }&#10;            }&#10;&#10;            string stringDateTime = $&quot;{issueDate}T{issueTime}&quot;;&#10;            if (DateTime.TryParseExact(stringDateTime, &quot;yyyy-MM-ddTHH:mm:ss&quot;,&#10;                    CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime dateTime))&#10;            {&#10;                return dateTime.ToString(dateTimeFormatPattern, CultureInfo.InvariantCulture);&#10;            }&#10;&#10;            return stringDateTime;&#10;        }&#10;&#10;        private string? getNodeXmlTextValue(XmlDocument document,&#10;            Dictionary&lt;string, string&gt; nameSpaces, string attributeXpath)&#10;        {&#10;            var namespaceManager = new XmlNamespaceManager(document.NameTable);&#10;&#10;            &#10;            foreach (var ns in nameSpaces)&#10;            {&#10;                if (string.IsNullOrEmpty(ns.Key))&#10;                {&#10;                    namespaceManager.AddNamespace(&quot;def&quot;, ns.Value); // Use 'def' for default namespace&#10;                }&#10;                else&#10;                {&#10;                    namespaceManager.AddNamespace(ns.Key, ns.Value);&#10;                }&#10;            }&#10;&#10;            // Replace /Invoice with /def:Invoice in xpath if it starts with /Invoice&#10;            if (attributeXpath.StartsWith(&quot;/Invoice/&quot;))&#10;            {&#10;                attributeXpath = attributeXpath.Replace(&quot;/Invoice/&quot;, &quot;/def:Invoice/&quot;);&#10;            }&#10;&#10;            XmlNode? node = document.SelectSingleNode(attributeXpath, namespaceManager);&#10;            if (node == null)&#10;            {&#10;                log.LogDebug(&quot;XML node not found for path: {AttributeXpath}&quot;, attributeXpath);&#10;                return null;&#10;            }&#10;&#10;            return node.InnerText;&#10;        }&#10;&#10;        public string readUuid(string xmlDocument)&#10;        {&#10;            try&#10;            {&#10;                XmlDocument document = getXmlDocument(xmlDocument);&#10;                var nameSpaces = getNameSpacesMap();&#10;&#10;&#10;                string? uuid = getNodeXmlTextValue(document, nameSpaces, &quot;/Invoice/cbc:UUID&quot;);&#10;&#10;                if (string.IsNullOrEmpty(uuid))&#10;                {&#10;                    log.LogWarning(&quot;UUID not found in invoice document&quot;);&#10;                    return string.Empty;&#10;                }&#10;&#10;                return uuid;&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                log.LogError(ex, &quot;Failed to read UUID from XML document&quot;);&#10;                throw;&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Converts certificate serial number to base 10 format&#10;        /// &lt;/summary&gt;&#10;        private static string convertSerialNumberToBase10(string serialNumber)&#10;        {&#10;            try&#10;            {&#10;                // Remove any whitespace or formatting&#10;                serialNumber = serialNumber.Trim();&#10;                &#10;                // If it's already in decimal format, return as is&#10;                if (serialNumber.All(c =&gt; char.IsDigit(c)))&#10;                {&#10;                    return serialNumber;&#10;                }&#10;                &#10;                // If it contains hex characters (A-F), treat as hexadecimal&#10;                if (serialNumber.Any(c =&gt; &quot;ABCDEFabcdef&quot;.Contains(c)))&#10;                {&#10;                    // Remove any hex prefix if present&#10;                    if (serialNumber.StartsWith(&quot;0x&quot;, StringComparison.OrdinalIgnoreCase))&#10;                    {&#10;                        serialNumber = serialNumber.Substring(2);&#10;                    }&#10;                    &#10;                    // Convert from hex to decimal&#10;                    var decimalValue = System.Numerics.BigInteger.Parse(serialNumber, NumberStyles.HexNumber);&#10;                    return decimalValue.ToString();&#10;                }&#10;                &#10;                // Try to parse as hex anyway (some certificates have hex without obvious indicators)&#10;                try&#10;                {&#10;                    var decimalValue = System.Numerics.BigInteger.Parse(serialNumber, NumberStyles.HexNumber);&#10;                    return decimalValue.ToString();&#10;                }&#10;                catch&#10;                {&#10;                    // If all else fails, return the original string&#10;                    return serialNumber;&#10;                }&#10;            }&#10;            catch (Exception)&#10;            {&#10;                // If conversion fails, return the original string&#10;                return serialNumber;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/resources/xml/signature.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/resources/xml/signature.xml" />
              <option name="originalContent" value="&lt;cac:Signature xmlns:cac=&quot;urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2&quot; xmlns:cbc=&quot;urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2&quot;&gt;&#10;    &lt;cbc:ID&gt;urn:oasis:names:specification:ubl:signature:Invoice&lt;/cbc:ID&gt;&#10;    &lt;cbc:SignatureMethod&gt;urn:oasis:names:specification:ubl:dsig:enveloped:xades&lt;/cbc:SignatureMethod&gt;&#10;&lt;/cac:Signature&gt;" />
              <option name="updatedContent" value="&lt;cac:Signature&gt;&#13;&#10;    &lt;cbc:ID&gt;urn:oasis:names:specification:ubl:signature:Invoice&lt;/cbc:ID&gt;&#13;&#10;    &lt;cbc:SignatureMethod&gt;urn:oasis:names:specification:ubl:dsig:enveloped:xades&lt;/cbc:SignatureMethod&gt;&#13;&#10;&lt;/cac:Signature&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/resources/xslt/addUBLElement.xsl">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/resources/xslt/addUBLElement.xsl" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;xsl:stylesheet xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;   xmlns:ext=&quot;urn:oasis:names:specification:ubl:schema:xsd:CommonExtensionComponents-2&quot; xmlns:sac=&quot;urn:oasis:names:specification:ubl:schema:xsd:SignatureAggregateComponents-2&quot;&#10;                xmlns:sbc=&quot;urn:oasis:names:specification:ubl:schema:xsd:SignatureBasicComponents-2&quot;&#10;                xmlns:cbc=&quot;urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2&quot;&#10;                xmlns:sig=&quot;urn:oasis:names:specification:ubl:schema:xsd:CommonSignatureComponents-2&quot; version=&quot;1.0&quot;&gt;&#10;    &lt;xsl:output method=&quot;xml&quot; encoding=&quot;utf-8&quot; indent=&quot;no&quot;/&gt;&#10;&#10;    &lt;xsl:param name=&quot;ublExt&quot;&gt;UBL-TO-BE-REPLACED&lt;/xsl:param&gt;&#10;&#10;    &lt;xsl:template match=&quot;//*[local-name()='Invoice']&quot;&gt;&#10;        &lt;xsl:copy&gt;&#10;            &lt;xsl:copy-of select=&quot;@*&quot;/&gt;&#10;            &lt;xsl:copy-of select=&quot;$ublExt&quot; /&gt;&#10;            &lt;xsl:copy-of select=&quot;node()&quot;/&gt;&#10;        &lt;/xsl:copy&gt;&#10;    &lt;/xsl:template&gt;&#10;    &lt;xsl:template match=&quot;@* | node()&quot;&gt;&#10;        &lt;xsl:copy&gt;&#10;            &lt;xsl:apply-templates select=&quot;@* | node()&quot;/&gt;&#10;        &lt;/xsl:copy&gt;&#10;    &lt;/xsl:template&gt;&#10;&#10;&lt;/xsl:stylesheet&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;xsl:stylesheet xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;   xmlns:ext=&quot;urn:oasis:names:specification:ubl:schema:xsd:CommonExtensionComponents-2&quot; xmlns:sac=&quot;urn:oasis:names:specification:ubl:schema:xsd:SignatureAggregateComponents-2&quot;&#10;                xmlns:sbc=&quot;urn:oasis:names:specification:ubl:schema:xsd:SignatureBasicComponents-2&quot;&#10;                xmlns:cbc=&quot;urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2&quot;&#10;                xmlns:sig=&quot;urn:oasis:names:specification:ubl:schema:xsd:CommonSignatureComponents-2&quot; version=&quot;1.0&quot;&gt;&#10;    &lt;xsl:output method=&quot;xml&quot; encoding=&quot;utf-8&quot; indent=&quot;no&quot;/&gt;&#10;&#10;    &lt;xsl:param name=&quot;ublExt&quot;&gt;UBL-TO-BE-REPLACED&lt;/xsl:param&gt;&#10;&#10;    &lt;xsl:template match=&quot;//*[local-name()='Invoice']&quot;&gt;&#10;        &lt;xsl:copy&gt;&#10;            &lt;xsl:copy-of select=&quot;@*&quot;/&gt;&#10;            &lt;xsl:copy-of select=&quot;$ublExt&quot; /&gt;&#10;            &lt;xsl:copy-of select=&quot;node()&quot;/&gt;&#10;        &lt;/xsl:copy&gt;&#10;    &lt;/xsl:template&gt;&#10;    &lt;xsl:template match=&quot;@* | node()&quot;&gt;&#10;        &lt;xsl:copy&gt;&#10;            &lt;xsl:apply-templates select=&quot;@* | node()&quot;/&gt;&#10;        &lt;/xsl:copy&gt;&#10;    &lt;/xsl:template&gt;&#10;&#10;&lt;/xsl:stylesheet&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/utils/ECDSAUtils.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/utils/ECDSAUtils.cs" />
              <option name="originalContent" value="using System;&#10;using Org.BouncyCastle.Asn1;&#10;using Org.BouncyCastle.Asn1.Sec;&#10;using Org.BouncyCastle.Asn1.X9;&#10;using Org.BouncyCastle.Crypto;&#10;using Org.BouncyCastle.Crypto.Generators;&#10;using Org.BouncyCastle.Crypto.Parameters;&#10;using Org.BouncyCastle.Math;&#10;using Org.BouncyCastle.Security;&#10;using Org.BouncyCastle.OpenSsl;&#10;using System.IO;&#10;using System.Security.Cryptography;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.utils;&#10;public class ECDSAUtils&#10;{&#10;    public static AsymmetricCipherKeyPair getKeyPair()&#10;    {&#10;        var curve = SecNamedCurves.GetByName(&quot;secp256k1&quot;);&#10;        var domainParams = new ECDomainParameters(curve.Curve, curve.G, curve.N, curve.H);&#10;&#10;        &#10;        var keyGen = new ECKeyPairGenerator();&#10;        var secureRandom = new SecureRandom();&#10;        var keyGenParam = new ECKeyGenerationParameters(domainParams, secureRandom);&#10;        keyGen.Init(keyGenParam);&#10;        &#10;        return keyGen.GenerateKeyPair();&#10;    }&#10;&#10;    public static RSA getPrivateKey(string base64Key)&#10;    {&#10;        try&#10;        {&#10;            byte[] keyBytes = Convert.FromBase64String(base64Key);&#10;            &#10;            // Try to load as encrypted PKCS#8 first&#10;            try&#10;            {&#10;                RSA rsa = RSA.Create();&#10;                rsa.ImportPkcs8PrivateKey(keyBytes, out _);&#10;                return rsa;&#10;            }&#10;            catch&#10;            {&#10;                // If that fails, try as encrypted PKCS#8 with empty password&#10;                try&#10;                {&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportEncryptedPkcs8PrivateKey(&quot;&quot;, keyBytes, out _);&#10;                    return rsa;&#10;                }&#10;                catch&#10;                {&#10;                    // If both fail, try as RSA private key&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportRSAPrivateKey(keyBytes, out _);&#10;                    return rsa;&#10;                }&#10;            }&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            throw new ArgumentException(&quot;Failed to parse RSA private key: &quot; + ex.Message, ex);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using Org.BouncyCastle.Asn1;&#10;using Org.BouncyCastle.Asn1.Sec;&#10;using Org.BouncyCastle.Asn1.X9;&#10;using Org.BouncyCastle.Crypto;&#10;using Org.BouncyCastle.Crypto.Generators;&#10;using Org.BouncyCastle.Crypto.Parameters;&#10;using Org.BouncyCastle.Math;&#10;using Org.BouncyCastle.Security;&#10;using Org.BouncyCastle.OpenSsl;&#10;using System.IO;&#10;using System.Security.Cryptography;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.utils;&#10;public class ECDSAUtils&#10;{&#10;    public static AsymmetricCipherKeyPair getKeyPair()&#10;    {&#10;        var curve = SecNamedCurves.GetByName(&quot;secp256k1&quot;);&#10;        var domainParams = new ECDomainParameters(curve.Curve, curve.G, curve.N, curve.H);&#10;&#10;        &#10;        var keyGen = new ECKeyPairGenerator();&#10;        var secureRandom = new SecureRandom();&#10;        var keyGenParam = new ECKeyGenerationParameters(domainParams, secureRandom);&#10;        keyGen.Init(keyGenParam);&#10;        &#10;        return keyGen.GenerateKeyPair();&#10;    }&#10;&#10;    public static RSA getPrivateKey(string base64Key)&#10;    {&#10;        try&#10;        {&#10;            byte[] keyBytes = Convert.FromBase64String(base64Key);&#10;            &#10;            // Try to load as encrypted PKCS#8 first&#10;            try&#10;            {&#10;                RSA rsa = RSA.Create();&#10;                rsa.ImportPkcs8PrivateKey(keyBytes, out _);&#10;                return rsa;&#10;            }&#10;            catch&#10;            {&#10;                // If that fails, try as encrypted PKCS#8 with empty password&#10;                try&#10;                {&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportEncryptedPkcs8PrivateKey(&quot;&quot;, keyBytes, out _);&#10;                    return rsa;&#10;                }&#10;                catch&#10;                {&#10;                    // If both fail, try as RSA private key&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportRSAPrivateKey(keyBytes, out _);&#10;                    return rsa;&#10;                }&#10;            }&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            throw new ArgumentException(&quot;Failed to parse RSA private key: &quot; + ex.Message, ex);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>