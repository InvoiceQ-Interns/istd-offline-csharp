<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/dto/CsrConfigDto.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/dto/CsrConfigDto.cs" />
              <option name="originalContent" value="using Newtonsoft.Json;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.DTOs&#10;{&#10;    public class CsrConfigDto&#10;    {&#10;&#10;        private string enName;&#10;&#10;        private string serialNumber;&#10;        &#10;        [JsonProperty(&quot;keySize&quot;)]&#10;        private int keySize = 2048;&#10;        &#10;        [JsonProperty(&quot;templateOid&quot;)]&#10;        private string templateOid;&#10;&#10;        [JsonProperty(&quot;major&quot;)] &#10;        private int majorVersion;&#10;&#10;        [JsonProperty(&quot;minor&quot;)] &#10;        private int minorVersion;&#10;&#10;        public CsrConfigDto() { }&#10;&#10;        public string getEnName()&#10;        {&#10;            return enName;&#10;        }&#10;&#10;        public void setEnName(string enName)&#10;        {&#10;            this.enName = enName;&#10;        }&#10;&#10;        public string getSerialNumber()&#10;        {&#10;            return serialNumber;&#10;        }&#10;&#10;        public void setSerialNumber(string serialNumber)&#10;        {&#10;            this.serialNumber = serialNumber;&#10;        }&#10;&#10;        public string getKeyPassword()&#10;        {&#10;            return keyPassword;&#10;        }&#10;&#10;        public void setKeyPassword(string keyPassword)&#10;        {&#10;            this.keyPassword = keyPassword;&#10;        }&#10;&#10;        public int getKeySize()&#10;        {&#10;            return keySize;&#10;        }&#10;&#10;        public void setKeySize(int keySize)&#10;        {&#10;            this.keySize = keySize;&#10;        }&#10;&#10;        public string getTemplateOid()&#10;        {&#10;            return templateOid;&#10;        }&#10;&#10;        public void setTemplateOid(string templateOid)&#10;        {&#10;            this.templateOid = templateOid;&#10;        }&#10;&#10;        public int getMajorVersion()&#10;        {&#10;            return majorVersion;&#10;        }&#10;&#10;        public void setMajorVersion(int majorVersion)&#10;        {&#10;            this.majorVersion = majorVersion;&#10;        }&#10;&#10;        public int getMinorVersion()&#10;        {&#10;            return minorVersion;&#10;        }&#10;&#10;        public void setMinorVersion(int minorVersion)&#10;        {&#10;            this.minorVersion = minorVersion;&#10;        }&#10;&#10;        public string getPassword()&#10;        {&#10;            return keyPassword;&#10;        }&#10;&#10;        public string getSubjectDn()&#10;        {&#10;            if (string.IsNullOrWhiteSpace(enName) || string.IsNullOrWhiteSpace(serialNumber))&#10;            {&#10;                return null;&#10;            }&#10;&#10;            return $&quot;CN={enName.Trim()}, O=Government of Jordan, OU=eID, SerialNumber={serialNumber.Trim()}, C=JO&quot;;&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using Newtonsoft.Json;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.DTOs&#10;{&#10;    public class CsrConfigDto&#10;    {&#10;&#10;        private string enName;&#10;&#10;        private string serialNumber;&#10;        &#10;        [JsonProperty(&quot;keySize&quot;)]&#10;        private int keySize = 2048;&#10;        &#10;        [JsonProperty(&quot;templateOid&quot;)]&#10;        private string templateOid;&#10;&#10;        [JsonProperty(&quot;major&quot;)] &#10;        private int majorVersion;&#10;&#10;        [JsonProperty(&quot;minor&quot;)] &#10;        private int minorVersion;&#10;&#10;        public CsrConfigDto() { }&#10;&#10;        public string getEnName()&#10;        {&#10;            return enName;&#10;        }&#10;&#10;        public void setEnName(string enName)&#10;        {&#10;            this.enName = enName;&#10;        }&#10;&#10;        public string getSerialNumber()&#10;        {&#10;            return serialNumber;&#10;        }&#10;&#10;        public void setSerialNumber(string serialNumber)&#10;        {&#10;            this.serialNumber = serialNumber;&#10;        }&#10;&#10;        public int getKeySize()&#10;        {&#10;            return keySize;&#10;        }&#10;&#10;        public void setKeySize(int keySize)&#10;        {&#10;            this.keySize = keySize;&#10;        }&#10;&#10;        public string getTemplateOid()&#10;        {&#10;            return templateOid;&#10;        }&#10;&#10;        public void setTemplateOid(string templateOid)&#10;        {&#10;            this.templateOid = templateOid;&#10;        }&#10;&#10;        public int getMajorVersion()&#10;        {&#10;            return majorVersion;&#10;        }&#10;&#10;        public void setMajorVersion(int majorVersion)&#10;        {&#10;            this.majorVersion = majorVersion;&#10;        }&#10;&#10;        public int getMinorVersion()&#10;        {&#10;            return minorVersion;&#10;        }&#10;&#10;        public void setMinorVersion(int minorVersion)&#10;        {&#10;            this.minorVersion = minorVersion;&#10;        }&#10;&#10;        public string getSubjectDn()&#10;        {&#10;            if (string.IsNullOrWhiteSpace(enName) || string.IsNullOrWhiteSpace(serialNumber))&#10;            {&#10;                return null;&#10;            }&#10;&#10;            return $&quot;CN={enName.Trim()}, O=Government of Jordan, OU=eID, SerialNumber={serialNumber.Trim()}, C=JO&quot;;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/helper/CmsRequestHelper.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/helper/CmsRequestHelper.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Security.Cryptography;&#10;using System.Security.Cryptography.X509Certificates;&#10;using System.Formats.Asn1;&#10;using System.Text;&#10;using ISTD_OFFLINE_CSHARP.DTOs;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.Helper&#10;{&#10;    public static class CmsRequestHelper&#10;    {&#10;        public static CsrResponseDto createCsr(CsrConfigDto config)&#10;        {&#10;            using RSA rsa = RSA.Create(config.getKeySize());&#10;&#10;            var certReq = new CertificateRequest(&#10;                config.getSubjectDn(),&#10;                rsa,&#10;                HashAlgorithmName.SHA256,&#10;                RSASignaturePadding.Pkcs1);&#10;&#10;            addSubjectKeyIdentifier(certReq, rsa);&#10;&#10;            if (!string.IsNullOrEmpty(config.getTemplateOid()))&#10;            {&#10;                addCertificateTemplateExtension(certReq, config.getTemplateOid(),&#10;                    config.getMajorVersion(), config.getMinorVersion());&#10;            }&#10;&#10;            byte[] pkcs10Der = certReq.CreateSigningRequest();&#10;&#10;            byte[] privateKeyBytes = exportPkcs8PrivateKey(rsa);&#10;&#10;            return new CsrResponseDto(pkcs10Der, privateKeyBytes);&#10;        }&#10;&#10;        private static void addSubjectKeyIdentifier(CertificateRequest certReq, RSA rsa)&#10;        {&#10;            byte[] publicKeyBytes = rsa.ExportSubjectPublicKeyInfo();&#10;            byte[] skiBytes = SHA1.HashData(publicKeyBytes);&#10;&#10;            AsnWriter skiWriter = new AsnWriter(AsnEncodingRules.DER);&#10;            skiWriter.WriteOctetString(skiBytes);&#10;            var skiExtension = new X509Extension(&quot;2.5.29.14&quot;, skiWriter.Encode(), false);&#10;            certReq.CertificateExtensions.Add(skiExtension);&#10;        }&#10;&#10;        private static void addCertificateTemplateExtension(CertificateRequest certReq, string oid,&#10;            int majorVersion, int minorVersion)&#10;        {&#10;            byte[] templateExtension = buildCertificateTemplateExtension(oid, majorVersion, minorVersion);&#10;            certReq.CertificateExtensions.Add(new X509Extension(&quot;1.3.6.1.4.1.311.21.7&quot;, templateExtension, false));&#10;        }&#10;&#10;        private static byte[] buildCertificateTemplateExtension(string oid, int majorVersion, int minorVersion)&#10;        {&#10;            var writer = new AsnWriter(AsnEncodingRules.DER);&#10;            writer.PushSequence();&#10;            writer.WriteObjectIdentifier(oid);&#10;            writer.WriteInteger(majorVersion);&#10;            writer.WriteInteger(minorVersion);&#10;            writer.PopSequence();&#10;            return writer.Encode();&#10;        }&#10;&#10;        private static byte[] exportPkcs8PrivateKey(RSA rsa)&#10;        {&#10;            try&#10;            {&#10;                return rsa.ExportPkcs8PrivateKey();&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                throw new Exception(&quot;Failed to export private key: &quot; + e.Message, e);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Security.Cryptography;&#10;using System.Security.Cryptography.X509Certificates;&#10;using System.Formats.Asn1;&#10;using System.Text;&#10;using ISTD_OFFLINE_CSHARP.DTOs;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.Helper&#10;{&#10;    public static class CmsRequestHelper&#10;    {&#10;        public static CsrResponseDto createCsr(CsrConfigDto config)&#10;        {&#10;            using RSA rsa = RSA.Create(config.getKeySize());&#10;&#10;            var certReq = new CertificateRequest(&#10;                config.getSubjectDn(),&#10;                rsa,&#10;                HashAlgorithmName.SHA256,&#10;                RSASignaturePadding.Pkcs1);&#10;&#10;            addSubjectKeyIdentifier(certReq, rsa);&#10;&#10;            if (!string.IsNullOrEmpty(config.getTemplateOid()))&#10;            {&#10;                addCertificateTemplateExtension(certReq, config.getTemplateOid(),&#10;                    config.getMajorVersion(), config.getMinorVersion());&#10;            }&#10;&#10;            byte[] pkcs10Der = certReq.CreateSigningRequest();&#10;&#10;            byte[] privateKeyBytes = exportPkcs8PrivateKey(rsa);&#10;&#10;            return new CsrResponseDto(pkcs10Der, privateKeyBytes);&#10;        }&#10;&#10;        private static void addSubjectKeyIdentifier(CertificateRequest certReq, RSA rsa)&#10;        {&#10;            byte[] publicKeyBytes = rsa.ExportSubjectPublicKeyInfo();&#10;            byte[] skiBytes = SHA1.HashData(publicKeyBytes);&#10;&#10;            AsnWriter skiWriter = new AsnWriter(AsnEncodingRules.DER);&#10;            skiWriter.WriteOctetString(skiBytes);&#10;            var skiExtension = new X509Extension(&quot;2.5.29.14&quot;, skiWriter.Encode(), false);&#10;            certReq.CertificateExtensions.Add(skiExtension);&#10;        }&#10;&#10;        private static void addCertificateTemplateExtension(CertificateRequest certReq, string oid,&#10;            int majorVersion, int minorVersion)&#10;        {&#10;            byte[] templateExtension = buildCertificateTemplateExtension(oid, majorVersion, minorVersion);&#10;            certReq.CertificateExtensions.Add(new X509Extension(&quot;1.3.6.1.4.1.311.21.7&quot;, templateExtension, false));&#10;        }&#10;&#10;        private static byte[] buildCertificateTemplateExtension(string oid, int majorVersion, int minorVersion)&#10;        {&#10;            var writer = new AsnWriter(AsnEncodingRules.DER);&#10;            writer.PushSequence();&#10;            writer.WriteObjectIdentifier(oid);&#10;            writer.WriteInteger(majorVersion);&#10;            writer.WriteInteger(minorVersion);&#10;            writer.PopSequence();&#10;            return writer.Encode();&#10;        }&#10;&#10;        private static byte[] exportPkcs8PrivateKey(RSA rsa)&#10;        {&#10;            try&#10;            {&#10;                return rsa.ExportPkcs8PrivateKey();&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                throw new Exception(&quot;Failed to export private key: &quot; + e.Message, e);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/processor/impl/CsrKeysProcessor.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/processor/impl/CsrKeysProcessor.cs" />
              <option name="originalContent" value="using ISTD_OFFLINE_CSHARP.DTOs;&#10;using ISTD_OFFLINE_CSHARP.io;&#10;using ISTD_OFFLINE_CSHARP.processor;&#10;using ISTD_OFFLINE_CSHARP.security;&#10;using ISTD_OFFLINE_CSHARP.utils;&#10;using ISTD_OFFLINE_CSHARP.Helper;&#10;using Microsoft.Extensions.Logging;&#10;using Org.BouncyCastle.Utilities.IO.Pem;&#10;using System;&#10;using System.IO;&#10;using System.Security.Cryptography;&#10;using System.Text;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.ActionProcessor.impl&#10;{&#10;    public class CsrKeysProcessor : processor.ActionProcessor&#10;    {&#10;        private readonly ILogger log;&#10;&#10;        public CsrKeysProcessor()&#10;        {&#10;            this.log = LoggingUtils.getLoggerFactory().CreateLogger&lt;CsrKeysProcessor&gt;();&#10;        }&#10;&#10;        private string outputDirectory = &quot;&quot;;&#10;        private string configFilePath = &quot;&quot;;&#10;        private CsrConfigDto csrConfigDto;&#10;        private CsrResponseDto csrResponse;&#10;        private string csrPem;&#10;        private string csrDerBase64;&#10;        private string privateKeyBase64;&#10;        private string publicKeyPem;&#10;&#10;        protected override bool loadArgs(string[] args)&#10;        {&#10;            if (args.Length != 4)&#10;            {&#10;                log.LogInformation(&quot;Usage: dotnet run generate-csr-keys &lt;directory&gt; &lt;en-name&gt; &lt;serial-number&gt; &lt;config-file&gt;&quot;);&#10;                return false;&#10;            }&#10;&#10;            outputDirectory = args[0];&#10;            string enName = args[1];&#10;            string serialNumber = args[2];&#10;            configFilePath = args[3];&#10;&#10;            csrConfigDto = new CsrConfigDto();&#10;            csrConfigDto.setEnName(enName);&#10;            csrConfigDto.setSerialNumber(serialNumber);&#10;&#10;            return true;&#10;        }&#10;&#10;        protected override bool validateArgs()&#10;        {&#10;            if (!ReaderHelper.isDirectoryExists(outputDirectory))&#10;            {&#10;                log.LogInformation($&quot;Output directory [{outputDirectory}] does not exist&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (string.IsNullOrWhiteSpace(configFilePath))&#10;            {&#10;                log.LogInformation(&quot;Config file path is required&quot;);&#10;                return false;&#10;            }&#10;&#10;            string configFile = ReaderHelper.readFileAsString(configFilePath);&#10;            if (string.IsNullOrWhiteSpace(configFile))&#10;            {&#10;                log.LogInformation($&quot;Config file [{configFilePath}] is empty&quot;);&#10;                return false;&#10;            }&#10;&#10;            CsrConfigDto configFromFile = JsonUtils.readJson&lt;CsrConfigDto&gt;(configFile);&#10;            if (configFromFile == null)&#10;            {&#10;                log.LogInformation($&quot;Config file [{configFilePath}] is invalid&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (configFromFile.getKeySize() &gt; 0)&#10;            {&#10;                csrConfigDto.setKeySize(configFromFile.getKeySize());&#10;            }&#10;            if (!string.IsNullOrWhiteSpace(configFromFile.getTemplateOid()))&#10;            {&#10;                csrConfigDto.setTemplateOid(configFromFile.getTemplateOid());&#10;            }&#10;            if (configFromFile.getMajorVersion() &gt; 0)&#10;            {&#10;                csrConfigDto.setMajorVersion(configFromFile.getMajorVersion());&#10;            }&#10;            if (configFromFile.getMinorVersion() &gt;= 0)&#10;            {&#10;                csrConfigDto.setMinorVersion(configFromFile.getMinorVersion());&#10;            }&#10;&#10;            return validateCsrConfig();&#10;        }&#10;&#10;        private bool validateCsrConfig()&#10;        {&#10;            if (string.IsNullOrWhiteSpace(csrConfigDto.getEnName()))&#10;            {&#10;                log.LogInformation(&quot;Please enter a valid Name.&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (string.IsNullOrWhiteSpace(csrConfigDto.getSerialNumber()))&#10;            {&#10;                log.LogInformation(&quot;Please enter a valid Serial Number.&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (csrConfigDto.getKeySize() &lt; 1024)&#10;            {&#10;                log.LogInformation(&quot;Key size must be at least 1024 bits&quot;);&#10;                return false;&#10;            }&#10;&#10;            return true;&#10;        }&#10;&#10;        protected override bool process()&#10;        {&#10;            try&#10;            {&#10;                string subjectDn = csrConfigDto.getSubjectDn();&#10;                log.LogInformation($&quot;Generated DN: {subjectDn}&quot;);&#10;                log.LogInformation($&quot;RSA key size: {csrConfigDto.getKeySize()}&quot;);&#10;&#10;                if (!string.IsNullOrWhiteSpace(csrConfigDto.getTemplateOid()))&#10;                {&#10;                    log.LogInformation($&quot;Certificate template OID: {csrConfigDto.getTemplateOid()} (v{csrConfigDto.getMajorVersion()}.{csrConfigDto.getMinorVersion()})&quot;);&#10;                }&#10;                &#10;                csrResponse = CmsRequestHelper.createCsr(csrConfigDto);&#10;                &#10;                byte[] publicKeyBytes = extractPublicKeyFromPrivateKey(csrResponse.getPrivateKeyBytes());&#10;&#10;                string csrBase64 = Convert.ToBase64String(csrResponse.getCsrDer());&#10;                string cleanedCsr = StringUtils.CleanCsrString(csrBase64);&#10;&#10;                csrPem = convertToPem(&quot;CERTIFICATE REQUEST&quot;, csrResponse.getCsrDer());&#10;                csrDerBase64 = cleanedCsr;&#10;                privateKeyBase64 = Convert.ToBase64String(csrResponse.getPrivateKeyBytes());&#10;                publicKeyPem = convertToPem(&quot;PUBLIC KEY&quot;, publicKeyBytes);&#10;&#10;                log.LogInformation(&quot;Successfully generated CSR, unencrypted private key, and public key&quot;);&#10;                return true;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                log.LogError(e, &quot;Failed to generate CSR&quot;);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        private byte[] extractPublicKeyFromPrivateKey(byte[] privateKeyBytes)&#10;        {&#10;            using (RSA rsa = RSA.Create())&#10;            {&#10;                // Import the unencrypted private key&#10;                rsa.ImportPkcs8PrivateKey(privateKeyBytes, out _);&#10;                &#10;                // Export the public key&#10;                return rsa.ExportSubjectPublicKeyInfo();&#10;            }&#10;        }&#10;&#10;        protected override bool output()&#10;        {&#10;            string timestamp = DateTime.Now.ToString(&quot;yyyyMMdd_HHmmss&quot;);&#10;&#10;            string commonName = extractCommonNameFromDN(csrConfigDto.getSubjectDn());&#10;            string baseFileName = $&quot;{commonName}_{timestamp}&quot;;&#10;&#10;            string csrFile = Path.Combine(outputDirectory, $&quot;{baseFileName}.csr&quot;);&#10;            string keyFile = Path.Combine(outputDirectory, $&quot;{baseFileName}.key&quot;);&#10;            string pubFile = Path.Combine(outputDirectory, $&quot;{baseFileName}.pub&quot;);&#10;&#10;            bool valid = WriterHelper.writeFile(csrFile, SecurityUtils.encrypt(csrDerBase64));&#10;            valid = WriterHelper.writeFile(keyFile, SecurityUtils.encrypt(privateKeyBase64)) &amp;&amp; valid;&#10;            valid = WriterHelper.writeFile(pubFile, SecurityUtils.encrypt(publicKeyPem)) &amp;&amp; valid;&#10;&#10;            if (valid)&#10;            {&#10;                log.LogInformation($&quot;Successfully saved:&quot;);&#10;                log.LogInformation($&quot;  CSR: {csrFile}&quot;);&#10;                log.LogInformation($&quot;  Private Key: {keyFile}&quot;);&#10;                log.LogInformation($&quot;  Public Key: {pubFile}&quot;);&#10;            }&#10;&#10;            return valid;&#10;        }&#10;&#10;        private string extractCommonNameFromDN(string subjectDn)&#10;        {&#10;            try&#10;            {&#10;                string[] parts = subjectDn.Split(',');&#10;                foreach (string part in parts)&#10;                {&#10;                    string trimmed = part.Trim();&#10;                    if (trimmed.ToUpper().StartsWith(&quot;CN=&quot;))&#10;                    {&#10;                        return System.Text.RegularExpressions.Regex.Replace(&#10;                            trimmed.Substring(3).Trim(), &#10;                            &quot;[^a-zA-Z0-9_-]&quot;, &#10;                            &quot;_&quot;);&#10;                    }&#10;                }&#10;                return &quot;CSR&quot;;&#10;            }&#10;            catch (Exception)&#10;            {&#10;                return &quot;CSR&quot;;&#10;            }&#10;        }&#10;&#10;        private string convertToPem(string type, byte[] derBytes)&#10;        {&#10;            try&#10;            {&#10;                var pemObject = new PemObject(type, derBytes);&#10;                using var stringWriter = new StringWriter();&#10;                using var pemWriter = new Org.BouncyCastle.OpenSsl.PemWriter(stringWriter);&#10;                pemWriter.WriteObject(pemObject);&#10;                pemWriter.Writer.Flush();&#10;                return stringWriter.ToString();&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                log.LogError(e, &quot;Failed to convert to PEM format&quot;);&#10;                throw;&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using ISTD_OFFLINE_CSHARP.DTOs;&#10;using ISTD_OFFLINE_CSHARP.io;&#10;using ISTD_OFFLINE_CSHARP.processor;&#10;using ISTD_OFFLINE_CSHARP.security;&#10;using ISTD_OFFLINE_CSHARP.utils;&#10;using ISTD_OFFLINE_CSHARP.Helper;&#10;using Microsoft.Extensions.Logging;&#10;using Org.BouncyCastle.Utilities.IO.Pem;&#10;using System;&#10;using System.IO;&#10;using System.Security.Cryptography;&#10;using System.Text;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.ActionProcessor.impl&#10;{&#10;    public class CsrKeysProcessor : processor.ActionProcessor&#10;    {&#10;        private readonly ILogger log;&#10;&#10;        public CsrKeysProcessor()&#10;        {&#10;            this.log = LoggingUtils.getLoggerFactory().CreateLogger&lt;CsrKeysProcessor&gt;();&#10;        }&#10;&#10;        private string outputDirectory = &quot;&quot;;&#10;        private string configFilePath = &quot;&quot;;&#10;        private CsrConfigDto csrConfigDto;&#10;        private CsrResponseDto csrResponse;&#10;        private string csrPem;&#10;        private string csrDerBase64;&#10;        private string privateKeyBase64;&#10;        private string publicKeyPem;&#10;&#10;        protected override bool loadArgs(string[] args)&#10;        {&#10;            if (args.Length != 4)&#10;            {&#10;                log.LogInformation(&quot;Usage: dotnet run generate-csr-keys &lt;directory&gt; &lt;en-name&gt; &lt;serial-number&gt; &lt;config-file&gt;&quot;);&#10;                return false;&#10;            }&#10;&#10;            outputDirectory = args[0];&#10;            string enName = args[1];&#10;            string serialNumber = args[2];&#10;            configFilePath = args[3];&#10;&#10;            csrConfigDto = new CsrConfigDto();&#10;            csrConfigDto.setEnName(enName);&#10;            csrConfigDto.setSerialNumber(serialNumber);&#10;&#10;            return true;&#10;        }&#10;&#10;        protected override bool validateArgs()&#10;        {&#10;            if (!ReaderHelper.isDirectoryExists(outputDirectory))&#10;            {&#10;                log.LogInformation($&quot;Output directory [{outputDirectory}] does not exist&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (string.IsNullOrWhiteSpace(configFilePath))&#10;            {&#10;                log.LogInformation(&quot;Config file path is required&quot;);&#10;                return false;&#10;            }&#10;&#10;            string configFile = ReaderHelper.readFileAsString(configFilePath);&#10;            if (string.IsNullOrWhiteSpace(configFile))&#10;            {&#10;                log.LogInformation($&quot;Config file [{configFilePath}] is empty&quot;);&#10;                return false;&#10;            }&#10;&#10;            CsrConfigDto configFromFile = JsonUtils.readJson&lt;CsrConfigDto&gt;(configFile);&#10;            if (configFromFile == null)&#10;            {&#10;                log.LogInformation($&quot;Config file [{configFilePath}] is invalid&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (configFromFile.getKeySize() &gt; 0)&#10;            {&#10;                csrConfigDto.setKeySize(configFromFile.getKeySize());&#10;            }&#10;            if (!string.IsNullOrWhiteSpace(configFromFile.getTemplateOid()))&#10;            {&#10;                csrConfigDto.setTemplateOid(configFromFile.getTemplateOid());&#10;            }&#10;            if (configFromFile.getMajorVersion() &gt; 0)&#10;            {&#10;                csrConfigDto.setMajorVersion(configFromFile.getMajorVersion());&#10;            }&#10;            if (configFromFile.getMinorVersion() &gt;= 0)&#10;            {&#10;                csrConfigDto.setMinorVersion(configFromFile.getMinorVersion());&#10;            }&#10;&#10;            return validateCsrConfig();&#10;        }&#10;&#10;        private bool validateCsrConfig()&#10;        {&#10;            if (string.IsNullOrWhiteSpace(csrConfigDto.getEnName()))&#10;            {&#10;                log.LogInformation(&quot;Please enter a valid Name.&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (string.IsNullOrWhiteSpace(csrConfigDto.getSerialNumber()))&#10;            {&#10;                log.LogInformation(&quot;Please enter a valid Serial Number.&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (csrConfigDto.getKeySize() &lt; 1024)&#10;            {&#10;                log.LogInformation(&quot;Key size must be at least 1024 bits&quot;);&#10;                return false;&#10;            }&#10;&#10;            return true;&#10;        }&#10;&#10;        protected override bool process()&#10;        {&#10;            try&#10;            {&#10;                string subjectDn = csrConfigDto.getSubjectDn();&#10;                log.LogInformation($&quot;Generated DN: {subjectDn}&quot;);&#10;                log.LogInformation($&quot;RSA key size: {csrConfigDto.getKeySize()}&quot;);&#10;&#10;                if (!string.IsNullOrWhiteSpace(csrConfigDto.getTemplateOid()))&#10;                {&#10;                    log.LogInformation($&quot;Certificate template OID: {csrConfigDto.getTemplateOid()} (v{csrConfigDto.getMajorVersion()}.{csrConfigDto.getMinorVersion()})&quot;);&#10;                }&#10;                &#10;                csrResponse = CmsRequestHelper.createCsr(csrConfigDto);&#10;                &#10;                byte[] publicKeyBytes = extractPublicKeyFromPrivateKey(csrResponse.getPrivateKeyBytes());&#10;&#10;                string csrBase64 = Convert.ToBase64String(csrResponse.getCsrDer());&#10;                string cleanedCsr = StringUtils.CleanCsrString(csrBase64);&#10;&#10;                csrPem = convertToPem(&quot;CERTIFICATE REQUEST&quot;, csrResponse.getCsrDer());&#10;                csrDerBase64 = cleanedCsr;&#10;                privateKeyBase64 = Convert.ToBase64String(csrResponse.getPrivateKeyBytes());&#10;                publicKeyPem = convertToPem(&quot;PUBLIC KEY&quot;, publicKeyBytes);&#10;&#10;                log.LogInformation(&quot;Successfully generated CSR, unencrypted private key, and public key&quot;);&#10;                return true;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                log.LogError(e, &quot;Failed to generate CSR&quot;);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        private byte[] extractPublicKeyFromPrivateKey(byte[] privateKeyBytes)&#10;        {&#10;            using (RSA rsa = RSA.Create())&#10;            {&#10;                // Import the unencrypted private key&#10;                rsa.ImportPkcs8PrivateKey(privateKeyBytes, out _);&#10;                &#10;                // Export the public key&#10;                return rsa.ExportSubjectPublicKeyInfo();&#10;            }&#10;        }&#10;&#10;        protected override bool output()&#10;        {&#10;            string timestamp = DateTime.Now.ToString(&quot;yyyyMMdd_HHmmss&quot;);&#10;&#10;            string commonName = extractCommonNameFromDN(csrConfigDto.getSubjectDn());&#10;            string baseFileName = $&quot;{commonName}_{timestamp}&quot;;&#10;&#10;            string csrFile = Path.Combine(outputDirectory, $&quot;{baseFileName}.csr&quot;);&#10;            string keyFile = Path.Combine(outputDirectory, $&quot;{baseFileName}.key&quot;);&#10;            string pubFile = Path.Combine(outputDirectory, $&quot;{baseFileName}.pub&quot;);&#10;&#10;            bool valid = WriterHelper.writeFile(csrFile, SecurityUtils.encrypt(csrDerBase64));&#10;            valid = WriterHelper.writeFile(keyFile, SecurityUtils.encrypt(privateKeyBase64)) &amp;&amp; valid;&#10;            valid = WriterHelper.writeFile(pubFile, SecurityUtils.encrypt(publicKeyPem)) &amp;&amp; valid;&#10;&#10;            if (valid)&#10;            {&#10;                log.LogInformation($&quot;Successfully saved:&quot;);&#10;                log.LogInformation($&quot;  CSR: {csrFile}&quot;);&#10;                log.LogInformation($&quot;  Private Key: {keyFile}&quot;);&#10;                log.LogInformation($&quot;  Public Key: {pubFile}&quot;);&#10;            }&#10;&#10;            return valid;&#10;        }&#10;&#10;        private string extractCommonNameFromDN(string subjectDn)&#10;        {&#10;            try&#10;            {&#10;                string[] parts = subjectDn.Split(',');&#10;                foreach (string part in parts)&#10;                {&#10;                    string trimmed = part.Trim();&#10;                    if (trimmed.ToUpper().StartsWith(&quot;CN=&quot;))&#10;                    {&#10;                        return System.Text.RegularExpressions.Regex.Replace(&#10;                            trimmed.Substring(3).Trim(), &#10;                            &quot;[^a-zA-Z0-9_-]&quot;, &#10;                            &quot;_&quot;);&#10;                    }&#10;                }&#10;                return &quot;CSR&quot;;&#10;            }&#10;            catch (Exception)&#10;            {&#10;                return &quot;CSR&quot;;&#10;            }&#10;        }&#10;&#10;        private string convertToPem(string type, byte[] derBytes)&#10;        {&#10;            try&#10;            {&#10;                var pemObject = new PemObject(type, derBytes);&#10;                using var stringWriter = new StringWriter();&#10;                using var pemWriter = new Org.BouncyCastle.OpenSsl.PemWriter(stringWriter);&#10;                pemWriter.WriteObject(pemObject);&#10;                pemWriter.Writer.Flush();&#10;                return stringWriter.ToString();&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                log.LogError(e, &quot;Failed to convert to PEM format&quot;);&#10;                throw;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/processor/impl/InvoiceSignProcessor.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/processor/impl/InvoiceSignProcessor.cs" />
              <option name="originalContent" value="using System.Security.Cryptography;&#10;using ISTD_OFFLINE_CSHARP.DTOs;&#10;using ISTD_OFFLINE_CSHARP.helper;&#10;using ISTD_OFFLINE_CSHARP.Helper;&#10;using ISTD_OFFLINE_CSHARP.io;&#10;using ISTD_OFFLINE_CSHARP.security;&#10;using ISTD_OFFLINE_CSHARP.utils;&#10;using Microsoft.Extensions.Logging;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.ActionProcessor.impl;&#10;&#10;public class InvoiceSignProcessor : processor.ActionProcessor&#10;{&#10;    private readonly ILogger log;&#10;    private readonly SigningHelper signingHelper;&#10;    private string xmlPath = &quot;&quot;;&#10;    private string privateKeyPath = &quot;&quot;;&#10;    private string certificatePath = &quot;&quot;;&#10;    private string outputFile = &quot;&quot;;&#10;    private RSA privateKey;&#10;    private string xmlFile = &quot;&quot;;&#10;    private string certificateStr = &quot;&quot;;&#10;    private EInvoiceSigningResults signingResults;&#10;&#10;    public InvoiceSignProcessor()&#10;    {&#10;        this.log = LoggingUtils.getLoggerFactory().CreateLogger&lt;InvoiceSignProcessor&gt;();&#10;        this.signingHelper = new SigningHelper();&#10;    }&#10;&#10;    protected override bool loadArgs(string[] args)&#10;    {&#10;        if (args.Length != 4)&#10;        {&#10;            log?.LogInformation(&quot;Usage: dotnet run invoice-sign &lt;xml-path&gt; &lt;private-key-path&gt; &lt;certificate-path&gt; &lt;output-file&gt;&quot;);&#10;            return false;&#10;        }&#10;        xmlPath = args[0];&#10;        privateKeyPath = args[1];&#10;        certificatePath = args[2];&#10;        outputFile = args[3];&#10;        return true;&#10;    }&#10;    &#10;    protected override bool validateArgs()&#10;    {&#10;        if (string.IsNullOrWhiteSpace(outputFile))&#10;        {&#10;            log?.LogInformation(&quot;Invalid output path&quot;);&#10;            return false;&#10;        }&#10;&#10;        if (!readXmlFile()) return false;&#10;        if (!readPrivateKey()) return false;&#10;        return readCertificate();&#10;    }&#10;&#10;    protected override bool process()&#10;    {&#10;        if (signingHelper == null)&#10;        {&#10;            log?.LogError(&quot;SigningHelper is null. Initialization missing.&quot;);&#10;            return false;&#10;        }&#10;        &#10;        signingResults = signingHelper.signEInvoice(xmlFile, privateKey, certificateStr);&#10;        return signingResults != null &amp;&amp; !string.IsNullOrWhiteSpace(signingResults.getSignedXml());&#10;    }&#10;    &#10;    protected override bool output()&#10;    {&#10;        log?.LogInformation($@&quot;&#10;        invoice UUID [{signingResults.getInvoiceUUID()}]&#10;        invoice Hash [{signingResults.getInvoiceHash()}]&#10;        invoice QR Code: [{signingResults.getQrCode()}]&#10;        &quot;);&#10;&#10;        return WriterHelper.writeFile(outputFile, signingResults.getSignedXml());&#10;    }&#10;    &#10;    private bool readCertificate()&#10;    {&#10;        certificateStr = ReaderHelper.readFileAsString(certificatePath);&#10;        if (string.IsNullOrWhiteSpace(certificateStr))&#10;        {&#10;            log?.LogInformation($&quot;Certificate file [{certificatePath}] is empty&quot;);&#10;            return false;&#10;        }&#10;        certificateStr = SecurityUtils.decrypt(certificateStr);&#10;        return true;&#10;    }&#10;    &#10;    private bool readPrivateKey()&#10;    {&#10;        string privateKeyFile = ReaderHelper.readFileAsString(privateKeyPath);&#10;        if (string.IsNullOrWhiteSpace(privateKeyFile))&#10;        {&#10;            log?.LogInformation($&quot;Private key file [{privateKeyPath}] is empty&quot;);&#10;            return false;&#10;        }&#10;        try&#10;        {&#10;            privateKeyFile = SecurityUtils.decrypt(privateKeyFile);&#10;            &#10;            // Use the new PrivateKeyUtil to load the private key (no password needed)&#10;            privateKey = PrivateKeyUtil.loadPrivateKey(privateKeyFile, null);&#10;        }&#10;        catch (Exception e)&#10;        {&#10;            log?.LogError(e, $&quot;Failed to read private key [{privateKeyPath}]&quot;);&#10;            return false;&#10;        }&#10;        return true;&#10;    }&#10;   &#10;    private bool readXmlFile()&#10;    {&#10;        xmlFile = ReaderHelper.readFileAsString(xmlPath);&#10;        if (string.IsNullOrWhiteSpace(xmlFile))&#10;        {&#10;            log?.LogInformation($&quot;XML file [{xmlPath}] is empty&quot;);&#10;            return false;&#10;        }&#10;        return true;&#10;    }&#10;&#10;&#10;}" />
              <option name="updatedContent" value="using System.Security.Cryptography;&#10;using ISTD_OFFLINE_CSHARP.DTOs;&#10;using ISTD_OFFLINE_CSHARP.helper;&#10;using ISTD_OFFLINE_CSHARP.Helper;&#10;using ISTD_OFFLINE_CSHARP.io;&#10;using ISTD_OFFLINE_CSHARP.security;&#10;using ISTD_OFFLINE_CSHARP.utils;&#10;using Microsoft.Extensions.Logging;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.ActionProcessor.impl;&#10;&#10;public class InvoiceSignProcessor : processor.ActionProcessor&#10;{&#10;    private readonly ILogger log;&#10;    private readonly SigningHelper signingHelper;&#10;    private string xmlPath = &quot;&quot;;&#10;    private string privateKeyPath = &quot;&quot;;&#10;    private string certificatePath = &quot;&quot;;&#10;    private string outputFile = &quot;&quot;;&#10;    private RSA privateKey;&#10;    private string xmlFile = &quot;&quot;;&#10;    private string certificateStr = &quot;&quot;;&#10;    private EInvoiceSigningResults signingResults;&#10;&#10;    public InvoiceSignProcessor()&#10;    {&#10;        this.log = LoggingUtils.getLoggerFactory().CreateLogger&lt;InvoiceSignProcessor&gt;();&#10;        this.signingHelper = new SigningHelper();&#10;    }&#10;&#10;    protected override bool loadArgs(string[] args)&#10;    {&#10;        if (args.Length != 4)&#10;        {&#10;            log?.LogInformation(&quot;Usage: dotnet run invoice-sign &lt;xml-path&gt; &lt;private-key-path&gt; &lt;certificate-path&gt; &lt;output-file&gt;&quot;);&#10;            return false;&#10;        }&#10;        xmlPath = args[0];&#10;        privateKeyPath = args[1];&#10;        certificatePath = args[2];&#10;        outputFile = args[3];&#10;        return true;&#10;    }&#10;    &#10;    protected override bool validateArgs()&#10;    {&#10;        if (string.IsNullOrWhiteSpace(outputFile))&#10;        {&#10;            log?.LogInformation(&quot;Invalid output path&quot;);&#10;            return false;&#10;        }&#10;&#10;        if (!readXmlFile()) return false;&#10;        if (!readPrivateKey()) return false;&#10;        return readCertificate();&#10;    }&#10;&#10;    protected override bool process()&#10;    {&#10;        if (signingHelper == null)&#10;        {&#10;            log?.LogError(&quot;SigningHelper is null. Initialization missing.&quot;);&#10;            return false;&#10;        }&#10;        &#10;        signingResults = signingHelper.signEInvoice(xmlFile, privateKey, certificateStr);&#10;        return signingResults != null &amp;&amp; !string.IsNullOrWhiteSpace(signingResults.getSignedXml());&#10;    }&#10;    &#10;    protected override bool output()&#10;    {&#10;        log?.LogInformation($@&quot;&#10;        invoice UUID [{signingResults.getInvoiceUUID()}]&#10;        invoice Hash [{signingResults.getInvoiceHash()}]&#10;        invoice QR Code: [{signingResults.getQrCode()}]&#10;        &quot;);&#10;&#10;        return WriterHelper.writeFile(outputFile, signingResults.getSignedXml());&#10;    }&#10;    &#10;    private bool readCertificate()&#10;    {&#10;        certificateStr = ReaderHelper.readFileAsString(certificatePath);&#10;        if (string.IsNullOrWhiteSpace(certificateStr))&#10;        {&#10;            log?.LogInformation($&quot;Certificate file [{certificatePath}] is empty&quot;);&#10;            return false;&#10;        }&#10;        certificateStr = SecurityUtils.decrypt(certificateStr);&#10;        return true;&#10;    }&#10;    &#10;    private bool readPrivateKey()&#10;    {&#10;        string privateKeyFile = ReaderHelper.readFileAsString(privateKeyPath);&#10;        if (string.IsNullOrWhiteSpace(privateKeyFile))&#10;        {&#10;            log?.LogInformation($&quot;Private key file [{privateKeyPath}] is empty&quot;);&#10;            return false;&#10;        }&#10;        try&#10;        {&#10;            privateKeyFile = SecurityUtils.decrypt(privateKeyFile);&#10;            &#10;            // Use the new PrivateKeyUtil to load the private key (no password needed)&#10;            privateKey = PrivateKeyUtil.loadPrivateKey(privateKeyFile, null);&#10;        }&#10;        catch (Exception e)&#10;        {&#10;            log?.LogError(e, $&quot;Failed to read private key [{privateKeyPath}]&quot;);&#10;            return false;&#10;        }&#10;        return true;&#10;    }&#10;   &#10;    private bool readXmlFile()&#10;    {&#10;        xmlFile = ReaderHelper.readFileAsString(xmlPath);&#10;        if (string.IsNullOrWhiteSpace(xmlFile))&#10;        {&#10;            log?.LogInformation($&quot;XML file [{xmlPath}] is empty&quot;);&#10;            return false;&#10;        }&#10;        return true;&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/processor/impl/OnboardProcessor.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/processor/impl/OnboardProcessor.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.IO;&#10;using System.Linq;&#10;using System.Security.Cryptography;&#10;using System.Text;&#10;using System.Text.RegularExpressions;&#10;using ISTD_OFFLINE_CSHARP.client;&#10;using ISTD_OFFLINE_CSHARP.DTOs;&#10;using ISTD_OFFLINE_CSHARP.helper;&#10;using ISTD_OFFLINE_CSHARP.Helper;&#10;using ISTD_OFFLINE_CSHARP.io;&#10;using ISTD_OFFLINE_CSHARP.processor;&#10;using ISTD_OFFLINE_CSHARP.security;&#10;using ISTD_OFFLINE_CSHARP.utils;&#10;using Microsoft.Extensions.Logging;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.ActionProcessor.impl&#10;{&#10;    public class OnboardProcessor : processor.ActionProcessor&#10;    {&#10;        private static readonly string DateFormat = &quot;yyyy-MM-dd&quot;;&#10;&#10;        private string outputDirectory = &quot;&quot;;&#10;        private string configFilePath = &quot;&quot;;&#10;        private string csrEncoded = &quot;&quot;;&#10;        private RSA privateKey;&#10;        private string deviceId;&#10;        private string taxPayerNumber;&#10;        private CsrConfigDto csrConfigDto;&#10;        private string otp;&#10;        private string complianceCertificateStr;&#10;        private CertificateResponse complianceCsrResponse;&#10;        private CertificateResponse prodCertificateResponse;&#10;        private readonly Queue&lt;string&gt; testQueue = new Queue&lt;string&gt;();&#10;        private readonly Dictionary&lt;string, string&gt; signedXmlMap = new Dictionary&lt;string, string&gt;();&#10;        private readonly SigningHelper signingHelper = new SigningHelper();&#10;        private readonly RequesterGeneratorHelper requesterGeneratorHelper = new RequesterGeneratorHelper();&#10;        private FotaraClient client;&#10;&#10;        protected override bool loadArgs(string[] args)&#10;        {&#10;            if (args.Length != 5)&#10;            {&#10;                log?.LogInformation(&quot;Usage: dotnet run onboard &lt;otp&gt; &lt;output-directory&gt; &lt;en-name&gt; &lt;serial-number&gt; &lt;config-file&gt;&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (string.IsNullOrWhiteSpace(args[0]) || !Regex.IsMatch(args[0], @&quot;^\d{6}$&quot;))&#10;            {&#10;                log?.LogInformation(&quot;Invalid otp - must be 6 digits&quot;);&#10;                return false;&#10;            }&#10;&#10;            otp = args[0];&#10;            outputDirectory = args[1];&#10;            string enName = args[2];&#10;            string serialNumber = args[3];&#10;            configFilePath = args[4];&#10;&#10;            csrConfigDto = new CsrConfigDto();&#10;            csrConfigDto.setEnName(enName);&#10;            csrConfigDto.setSerialNumber(serialNumber);&#10;&#10;            client = new FotaraClient(propertiesManager);&#10;            return true;&#10;        }&#10;&#10;        protected override bool validateArgs()&#10;        {&#10;            if (!ReaderHelper.isDirectoryExists(outputDirectory))&#10;            {&#10;                log?.LogInformation($&quot;Output directory [{outputDirectory}] does not exist&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (string.IsNullOrWhiteSpace(configFilePath))&#10;            {&#10;                log?.LogInformation(&quot;Config file path is required&quot;);&#10;                return false;&#10;            }&#10;&#10;            string configFile = ReaderHelper.readFileAsString(configFilePath);&#10;            if (string.IsNullOrWhiteSpace(configFile))&#10;            {&#10;                log?.LogInformation($&quot;Config file [{configFilePath}] is empty&quot;);&#10;                return false;&#10;            }&#10;&#10;            CsrConfigDto configFromFile = JsonUtils.readJson&lt;CsrConfigDto&gt;(configFile);&#10;            if (configFromFile == null)&#10;            {&#10;                log?.LogInformation($&quot;Config file [{configFilePath}] is invalid&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (configFromFile.getKeySize() &gt; 0)&#10;            {&#10;                csrConfigDto.setKeySize(configFromFile.getKeySize());&#10;            }&#10;            if (!string.IsNullOrWhiteSpace(configFromFile.getTemplateOid()))&#10;            {&#10;                csrConfigDto.setTemplateOid(configFromFile.getTemplateOid());&#10;            }&#10;            if (configFromFile.getMajorVersion() &gt; 0)&#10;            {&#10;                csrConfigDto.setMajorVersion(configFromFile.getMajorVersion());&#10;            }&#10;            if (configFromFile.getMinorVersion() &gt;= 0)&#10;            {&#10;                csrConfigDto.setMinorVersion(configFromFile.getMinorVersion());&#10;            }&#10;&#10;            return true;&#10;        }&#10;&#10;        protected override bool process()&#10;        {&#10;            CsrKeysProcessor csrKeysProcessor = new CsrKeysProcessor();&#10;            string[] csrArgs = { outputDirectory, csrConfigDto.getEnName(), csrConfigDto.getSerialNumber(),&#10;                               configFilePath };&#10;            bool isValid = csrKeysProcessor.process(csrArgs, propertiesManager);&#10;            if (!isValid)&#10;            {&#10;                log?.LogError(&quot;Failed to generate CSR and keys&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (!loadPrivateKey())&#10;            {&#10;                log?.LogInformation(&quot;Failed to load private key&quot;);&#10;                return false;&#10;            }&#10;            if (!loadCsrConfigs())&#10;            {&#10;                log?.LogInformation(&quot;Failed to load CSR configs&quot;);&#10;                return false;&#10;            }&#10;            if (!complianceCsr())&#10;            {&#10;                log?.LogInformation(&quot;Failed to compliance csr&quot;);&#10;                return false;&#10;            }&#10;            if (!enrichTestQueue())&#10;            {&#10;                log?.LogInformation(&quot;Failed to create test xmls&quot;);&#10;                return false;&#10;            }&#10;            if (!complianceInvoices())&#10;            {&#10;                log?.LogInformation(&quot;Failed to compliance invoices&quot;);&#10;                return false;&#10;            }&#10;            if (!getProdCertificate())&#10;            {&#10;                log?.LogInformation(&quot;Failed to get prod certificate&quot;);&#10;                return false;&#10;            }&#10;            return true;&#10;        }&#10;&#10;        protected override bool output()&#10;        {&#10;            bool valid = true;&#10;            foreach (string key in signedXmlMap.Keys)&#10;            {&#10;                valid = WriterHelper.writeFile(outputDirectory + &quot;/&quot; + key, signedXmlMap[key]) &amp;&amp; valid;&#10;            }&#10;            string productCertificate = outputDirectory + &quot;/production_csid.cert&quot;;&#10;            string productionResponse = outputDirectory + &quot;/production_response.json&quot;;&#10;            valid = WriterHelper.writeFile(productionResponse, SecurityUtils.encrypt(JsonUtils.toJson(prodCertificateResponse))) &amp;&amp; valid;&#10;            valid = WriterHelper.writeFile(productCertificate,&#10;                    SecurityUtils.encrypt(Encoding.UTF8.GetString(Convert.FromBase64String(prodCertificateResponse.getBinarySecurityToken()))))&#10;                    &amp;&amp; valid;&#10;            return valid;&#10;        }&#10;&#10;        private bool loadCsrConfigs()&#10;        {&#10;            try&#10;            {&#10;                string timestamp = findLatestTimestamp();&#10;                if (timestamp == null)&#10;                {&#10;                    log?.LogError(&quot;No CSR files found in output directory&quot;);&#10;                    return false;&#10;                }&#10;&#10;                string commonName = extractCommonNameFromDN(csrConfigDto.getSubjectDn());&#10;                string baseFileName = $&quot;{commonName}_{timestamp}&quot;;&#10;                string csrFile = outputDirectory + &quot;/&quot; + baseFileName + &quot;.csr&quot;;&#10;&#10;                csrEncoded = SecurityUtils.decrypt(ReaderHelper.readFileAsString(csrFile));&#10;&#10;                string[] serialNumberParts = csrConfigDto.getSerialNumber().Split('|');&#10;                if (serialNumberParts.Length &gt;= 3)&#10;                {&#10;                    deviceId = serialNumberParts[2];&#10;                    taxPayerNumber = serialNumberParts[0];&#10;                }&#10;                else&#10;                {&#10;                    deviceId = &quot;1&quot;;&#10;                    taxPayerNumber = csrConfigDto.getSerialNumber();&#10;                }&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                log?.LogError(e, &quot;Failed to load CSR configs&quot;);&#10;                return false;&#10;            }&#10;            return true;&#10;        }&#10;&#10;        private bool loadPrivateKey()&#10;        {&#10;            try&#10;            {&#10;                string timestamp = findLatestTimestamp();&#10;                if (timestamp == null)&#10;                {&#10;                    log?.LogError(&quot;No private key files found in output directory&quot;);&#10;                    return false;&#10;                }&#10;&#10;                string commonName = extractCommonNameFromDN(csrConfigDto.getSubjectDn());&#10;                string baseFileName = $&quot;{commonName}_{timestamp}&quot;;&#10;                string keyFile = outputDirectory + &quot;/&quot; + baseFileName + &quot;.key&quot;;&#10;&#10;                string privateKeyBase64 = SecurityUtils.decrypt(ReaderHelper.readFileAsString(keyFile));&#10;                byte[] privateKeyBytes = Convert.FromBase64String(privateKeyBase64);&#10;&#10;                // Import as plain PKCS#8 (unencrypted)&#10;                privateKey = RSA.Create();&#10;                privateKey.ImportPkcs8PrivateKey(privateKeyBytes, out _);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                log?.LogError(e, &quot;Failed to load private key&quot;);&#10;                return false;&#10;            }&#10;            return true;&#10;        }&#10;&#10;        private bool getProdCertificate()&#10;        {&#10;            prodCertificateResponse = client.getProdCertificate(complianceCsrResponse, complianceCsrResponse.getRequestID());&#10;            return prodCertificateResponse != null &amp;&amp; string.Equals(prodCertificateResponse.getDispositionMessage(), &quot;ISSUED&quot;, StringComparison.OrdinalIgnoreCase);&#10;        }&#10;&#10;        private bool complianceInvoices()&#10;        {&#10;            bool valid = true;&#10;            int counter = 0;&#10;            while (testQueue.Count &gt; 0)&#10;            {&#10;                string xml = testQueue.Dequeue();&#10;                EInvoiceSigningResults signingResults = signingHelper.signEInvoice(xml, privateKey, complianceCertificateStr);&#10;&#10;                string jsonBody = requesterGeneratorHelper.generateEInvoiceRequest(signingResults.getInvoiceHash(), signingResults.getInvoiceUUID(), signingResults.getSignedXml());&#10;                ComplianceInvoiceResponse complianceInvoiceResponse = client.complianceInvoice(complianceCsrResponse, jsonBody);&#10;                if (complianceInvoiceResponse == null || !complianceInvoiceResponse.isValid())&#10;                {&#10;                    log?.LogInformation($&quot;Failed to compliance invoice [{Convert.ToBase64String(Encoding.UTF8.GetBytes(xml))}] and error [{JsonUtils.toJson(complianceInvoiceResponse)}]&quot;);&#10;                    valid = false;&#10;                }&#10;                else&#10;                {&#10;                    string id = $&quot;einvoice_test_{taxPayerNumber}_{deviceId}_{counter++}.xml&quot;;&#10;                    signedXmlMap[id] = signingResults.getSignedXml();&#10;                }&#10;            }&#10;            return valid;&#10;        }&#10;&#10;        private bool complianceCsr()&#10;        {&#10;            complianceCsrResponse = client.complianceCsr(otp, csrEncoded);&#10;            complianceCertificateStr = Encoding.UTF8.GetString(Convert.FromBase64String(complianceCsrResponse.getBinarySecurityToken()));&#10;            return complianceCsrResponse != null &amp;&amp; string.Equals(complianceCsrResponse.getDispositionMessage(), &quot;ISSUED&quot;, StringComparison.OrdinalIgnoreCase);&#10;        }&#10;&#10;        private bool enrichTestQueue()&#10;        {&#10;            bool valid = false;&#10;            try&#10;            {&#10;                int counter = 0;&#10;                testQueue.Enqueue(enrichFile(ReaderHelper.readFileFromResource(&quot;samples/b2b_invoice.xml&quot;) ?? throw new Exception(&quot;Missing b2b_invoice&quot;), counter++));&#10;                testQueue.Enqueue(enrichFile(ReaderHelper.readFileFromResource(&quot;samples/b2b_credit.xml&quot;) ?? throw new Exception(&quot;Missing b2b_credit&quot;), counter++));&#10;                valid = true;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                log?.LogError(e, &quot;Failed to enrich test queue&quot;);&#10;                return false;&#10;            }&#10;            return valid;&#10;        }&#10;&#10;        private string enrichFile(string file, int counter)&#10;        {&#10;            string id = $&quot;{taxPayerNumber}_{deviceId}_{counter}&quot;;&#10;            string orgId = $&quot;{taxPayerNumber}_{deviceId}_{counter - 1}&quot;;&#10;            string formattedDate = DateTime.Now.ToString(DateFormat);&#10;            &#10;            string enrichedFile = file.Replace(&quot;${ID}&quot;, id);&#10;            enrichedFile = enrichedFile.Replace(&quot;${UUID}&quot;, CreateGuid(id).ToString());&#10;            enrichedFile = enrichedFile.Replace(&quot;${ISSUE_DATE}&quot;, formattedDate);&#10;            enrichedFile = enrichedFile.Replace(&quot;${ORG_ID}&quot;, orgId);&#10;            enrichedFile = enrichedFile.Replace(&quot;${ORG_UUID}&quot;, CreateGuid(orgId).ToString());&#10;            enrichedFile = enrichedFile.Replace(&quot;${VAT_NUMBER}&quot;, taxPayerNumber);&#10;            enrichedFile = enrichedFile.Replace(&quot;${TAXPAYER_NAME}&quot;, csrConfigDto.getEnName());&#10;            enrichedFile = enrichedFile.Replace(&quot;${DEVICE_ID}&quot;, deviceId);&#10;            return enrichedFile;&#10;        }&#10;&#10;        private Guid CreateGuid(string input)&#10;        {&#10;            using (var md5 = MD5.Create())&#10;            {&#10;                byte[] hash = md5.ComputeHash(Encoding.UTF8.GetBytes(input));&#10;                return new Guid(hash);&#10;            }&#10;        }&#10;&#10;        private string findLatestTimestamp()&#10;        {&#10;            try&#10;            {&#10;                DirectoryInfo dir = new DirectoryInfo(outputDirectory);&#10;                FileInfo[] files = dir.GetFiles(&quot;*.csr&quot;).Concat(dir.GetFiles(&quot;*.key&quot;)).ToArray();&#10;                if (files.Length == 0)&#10;                {&#10;                    return null;&#10;                }&#10;&#10;                string latestTimestamp = null;&#10;                foreach (FileInfo file in files)&#10;                {&#10;                    string fileName = file.Name;&#10;                    string[] parts = fileName.Split('_');&#10;                    if (parts.Length &gt;= 2)&#10;                    {&#10;                        string timestamp = parts[parts.Length - 1].Replace(&quot;.csr&quot;, &quot;&quot;).Replace(&quot;.key&quot;, &quot;&quot;);&#10;                        if (latestTimestamp == null || string.Compare(timestamp, latestTimestamp) &gt; 0)&#10;                        {&#10;                            latestTimestamp = timestamp;&#10;                        }&#10;                    }&#10;                }&#10;                return latestTimestamp;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                log?.LogError(e, &quot;Failed to find latest timestamp&quot;);&#10;                return null;&#10;            }&#10;        }&#10;&#10;        private string extractCommonNameFromDN(string subjectDn)&#10;        {&#10;            try&#10;            {&#10;                string[] parts = subjectDn.Split(',');&#10;                foreach (string part in parts)&#10;                {&#10;                    string trimmed = part.Trim();&#10;                    if (trimmed.ToUpper().StartsWith(&quot;CN=&quot;))&#10;                    {&#10;                        return Regex.Replace(trimmed.Substring(3).Trim(), @&quot;[^a-zA-Z0-9_-]&quot;, &quot;_&quot;);&#10;                    }&#10;                }&#10;                return &quot;CSR&quot;;&#10;            }&#10;            catch (Exception)&#10;            {&#10;                return &quot;CSR&quot;;&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.IO;&#10;using System.Linq;&#10;using System.Security.Cryptography;&#10;using System.Text;&#10;using System.Text.RegularExpressions;&#10;using ISTD_OFFLINE_CSHARP.client;&#10;using ISTD_OFFLINE_CSHARP.DTOs;&#10;using ISTD_OFFLINE_CSHARP.helper;&#10;using ISTD_OFFLINE_CSHARP.Helper;&#10;using ISTD_OFFLINE_CSHARP.io;&#10;using ISTD_OFFLINE_CSHARP.processor;&#10;using ISTD_OFFLINE_CSHARP.security;&#10;using ISTD_OFFLINE_CSHARP.utils;&#10;using Microsoft.Extensions.Logging;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.ActionProcessor.impl&#10;{&#10;    public class OnboardProcessor : processor.ActionProcessor&#10;    {&#10;        private static readonly string DateFormat = &quot;yyyy-MM-dd&quot;;&#10;&#10;        private string outputDirectory = &quot;&quot;;&#10;        private string configFilePath = &quot;&quot;;&#10;        private string csrEncoded = &quot;&quot;;&#10;        private RSA privateKey;&#10;        private string deviceId;&#10;        private string taxPayerNumber;&#10;        private CsrConfigDto csrConfigDto;&#10;        private string otp;&#10;        private string complianceCertificateStr;&#10;        private CertificateResponse complianceCsrResponse;&#10;        private CertificateResponse prodCertificateResponse;&#10;        private readonly Queue&lt;string&gt; testQueue = new Queue&lt;string&gt;();&#10;        private readonly Dictionary&lt;string, string&gt; signedXmlMap = new Dictionary&lt;string, string&gt;();&#10;        private readonly SigningHelper signingHelper = new SigningHelper();&#10;        private readonly RequesterGeneratorHelper requesterGeneratorHelper = new RequesterGeneratorHelper();&#10;        private FotaraClient client;&#10;&#10;        protected override bool loadArgs(string[] args)&#10;        {&#10;            if (args.Length != 5)&#10;            {&#10;                log?.LogInformation(&quot;Usage: dotnet run onboard &lt;otp&gt; &lt;output-directory&gt; &lt;en-name&gt; &lt;serial-number&gt; &lt;config-file&gt;&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (string.IsNullOrWhiteSpace(args[0]) || !Regex.IsMatch(args[0], @&quot;^\d{6}$&quot;))&#10;            {&#10;                log?.LogInformation(&quot;Invalid otp - must be 6 digits&quot;);&#10;                return false;&#10;            }&#10;&#10;            otp = args[0];&#10;            outputDirectory = args[1];&#10;            string enName = args[2];&#10;            string serialNumber = args[3];&#10;            configFilePath = args[4];&#10;&#10;            csrConfigDto = new CsrConfigDto();&#10;            csrConfigDto.setEnName(enName);&#10;            csrConfigDto.setSerialNumber(serialNumber);&#10;&#10;            client = new FotaraClient(propertiesManager);&#10;            return true;&#10;        }&#10;&#10;        protected override bool validateArgs()&#10;        {&#10;            if (!ReaderHelper.isDirectoryExists(outputDirectory))&#10;            {&#10;                log?.LogInformation($&quot;Output directory [{outputDirectory}] does not exist&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (string.IsNullOrWhiteSpace(configFilePath))&#10;            {&#10;                log?.LogInformation(&quot;Config file path is required&quot;);&#10;                return false;&#10;            }&#10;&#10;            string configFile = ReaderHelper.readFileAsString(configFilePath);&#10;            if (string.IsNullOrWhiteSpace(configFile))&#10;            {&#10;                log?.LogInformation($&quot;Config file [{configFilePath}] is empty&quot;);&#10;                return false;&#10;            }&#10;&#10;            CsrConfigDto configFromFile = JsonUtils.readJson&lt;CsrConfigDto&gt;(configFile);&#10;            if (configFromFile == null)&#10;            {&#10;                log?.LogInformation($&quot;Config file [{configFilePath}] is invalid&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (configFromFile.getKeySize() &gt; 0)&#10;            {&#10;                csrConfigDto.setKeySize(configFromFile.getKeySize());&#10;            }&#10;            if (!string.IsNullOrWhiteSpace(configFromFile.getTemplateOid()))&#10;            {&#10;                csrConfigDto.setTemplateOid(configFromFile.getTemplateOid());&#10;            }&#10;            if (configFromFile.getMajorVersion() &gt; 0)&#10;            {&#10;                csrConfigDto.setMajorVersion(configFromFile.getMajorVersion());&#10;            }&#10;            if (configFromFile.getMinorVersion() &gt;= 0)&#10;            {&#10;                csrConfigDto.setMinorVersion(configFromFile.getMinorVersion());&#10;            }&#10;&#10;            return true;&#10;        }&#10;&#10;        protected override bool process()&#10;        {&#10;            CsrKeysProcessor csrKeysProcessor = new CsrKeysProcessor();&#10;            string[] csrArgs = { outputDirectory, csrConfigDto.getEnName(), csrConfigDto.getSerialNumber(),&#10;                               configFilePath };&#10;            bool isValid = csrKeysProcessor.process(csrArgs, propertiesManager);&#10;            if (!isValid)&#10;            {&#10;                log?.LogError(&quot;Failed to generate CSR and keys&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (!loadPrivateKey())&#10;            {&#10;                log?.LogInformation(&quot;Failed to load private key&quot;);&#10;                return false;&#10;            }&#10;            if (!loadCsrConfigs())&#10;            {&#10;                log?.LogInformation(&quot;Failed to load CSR configs&quot;);&#10;                return false;&#10;            }&#10;            if (!complianceCsr())&#10;            {&#10;                log?.LogInformation(&quot;Failed to compliance csr&quot;);&#10;                return false;&#10;            }&#10;            if (!enrichTestQueue())&#10;            {&#10;                log?.LogInformation(&quot;Failed to create test xmls&quot;);&#10;                return false;&#10;            }&#10;            if (!complianceInvoices())&#10;            {&#10;                log?.LogInformation(&quot;Failed to compliance invoices&quot;);&#10;                return false;&#10;            }&#10;            if (!getProdCertificate())&#10;            {&#10;                log?.LogInformation(&quot;Failed to get prod certificate&quot;);&#10;                return false;&#10;            }&#10;            return true;&#10;        }&#10;&#10;        protected override bool output()&#10;        {&#10;            bool valid = true;&#10;            foreach (string key in signedXmlMap.Keys)&#10;            {&#10;                valid = WriterHelper.writeFile(outputDirectory + &quot;/&quot; + key, signedXmlMap[key]) &amp;&amp; valid;&#10;            }&#10;            string productCertificate = outputDirectory + &quot;/production_csid.cert&quot;;&#10;            string productionResponse = outputDirectory + &quot;/production_response.json&quot;;&#10;            valid = WriterHelper.writeFile(productionResponse, SecurityUtils.encrypt(JsonUtils.toJson(prodCertificateResponse))) &amp;&amp; valid;&#10;            valid = WriterHelper.writeFile(productCertificate,&#10;                    SecurityUtils.encrypt(Encoding.UTF8.GetString(Convert.FromBase64String(prodCertificateResponse.getBinarySecurityToken()))))&#10;                    &amp;&amp; valid;&#10;            return valid;&#10;        }&#10;&#10;        private bool loadCsrConfigs()&#10;        {&#10;            try&#10;            {&#10;                string timestamp = findLatestTimestamp();&#10;                if (timestamp == null)&#10;                {&#10;                    log?.LogError(&quot;No CSR files found in output directory&quot;);&#10;                    return false;&#10;                }&#10;&#10;                string commonName = extractCommonNameFromDN(csrConfigDto.getSubjectDn());&#10;                string baseFileName = $&quot;{commonName}_{timestamp}&quot;;&#10;                string csrFile = outputDirectory + &quot;/&quot; + baseFileName + &quot;.csr&quot;;&#10;&#10;                csrEncoded = SecurityUtils.decrypt(ReaderHelper.readFileAsString(csrFile));&#10;&#10;                string[] serialNumberParts = csrConfigDto.getSerialNumber().Split('|');&#10;                if (serialNumberParts.Length &gt;= 3)&#10;                {&#10;                    deviceId = serialNumberParts[2];&#10;                    taxPayerNumber = serialNumberParts[0];&#10;                }&#10;                else&#10;                {&#10;                    deviceId = &quot;1&quot;;&#10;                    taxPayerNumber = csrConfigDto.getSerialNumber();&#10;                }&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                log?.LogError(e, &quot;Failed to load CSR configs&quot;);&#10;                return false;&#10;            }&#10;            return true;&#10;        }&#10;&#10;        private bool loadPrivateKey()&#10;        {&#10;            try&#10;            {&#10;                string timestamp = findLatestTimestamp();&#10;                if (timestamp == null)&#10;                {&#10;                    log?.LogError(&quot;No private key files found in output directory&quot;);&#10;                    return false;&#10;                }&#10;&#10;                string commonName = extractCommonNameFromDN(csrConfigDto.getSubjectDn());&#10;                string baseFileName = $&quot;{commonName}_{timestamp}&quot;;&#10;                string keyFile = outputDirectory + &quot;/&quot; + baseFileName + &quot;.key&quot;;&#10;&#10;                string privateKeyBase64 = SecurityUtils.decrypt(ReaderHelper.readFileAsString(keyFile));&#10;                byte[] privateKeyBytes = Convert.FromBase64String(privateKeyBase64);&#10;&#10;                // Import as plain PKCS#8 (unencrypted)&#10;                privateKey = RSA.Create();&#10;                privateKey.ImportPkcs8PrivateKey(privateKeyBytes, out _);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                log?.LogError(e, &quot;Failed to load private key&quot;);&#10;                return false;&#10;            }&#10;            return true;&#10;        }&#10;&#10;        private bool getProdCertificate()&#10;        {&#10;            prodCertificateResponse = client.getProdCertificate(complianceCsrResponse, complianceCsrResponse.getRequestID());&#10;            return prodCertificateResponse != null &amp;&amp; string.Equals(prodCertificateResponse.getDispositionMessage(), &quot;ISSUED&quot;, StringComparison.OrdinalIgnoreCase);&#10;        }&#10;&#10;        private bool complianceInvoices()&#10;        {&#10;            bool valid = true;&#10;            int counter = 0;&#10;            while (testQueue.Count &gt; 0)&#10;            {&#10;                string xml = testQueue.Dequeue();&#10;                EInvoiceSigningResults signingResults = signingHelper.signEInvoice(xml, privateKey, complianceCertificateStr);&#10;&#10;                string jsonBody = requesterGeneratorHelper.generateEInvoiceRequest(signingResults.getInvoiceHash(), signingResults.getInvoiceUUID(), signingResults.getSignedXml());&#10;                ComplianceInvoiceResponse complianceInvoiceResponse = client.complianceInvoice(complianceCsrResponse, jsonBody);&#10;                if (complianceInvoiceResponse == null || !complianceInvoiceResponse.isValid())&#10;                {&#10;                    log?.LogInformation($&quot;Failed to compliance invoice [{Convert.ToBase64String(Encoding.UTF8.GetBytes(xml))}] and error [{JsonUtils.toJson(complianceInvoiceResponse)}]&quot;);&#10;                    valid = false;&#10;                }&#10;                else&#10;                {&#10;                    string id = $&quot;einvoice_test_{taxPayerNumber}_{deviceId}_{counter++}.xml&quot;;&#10;                    signedXmlMap[id] = signingResults.getSignedXml();&#10;                }&#10;            }&#10;            return valid;&#10;        }&#10;&#10;        private bool complianceCsr()&#10;        {&#10;            complianceCsrResponse = client.complianceCsr(otp, csrEncoded);&#10;            complianceCertificateStr = Encoding.UTF8.GetString(Convert.FromBase64String(complianceCsrResponse.getBinarySecurityToken()));&#10;            return complianceCsrResponse != null &amp;&amp; string.Equals(complianceCsrResponse.getDispositionMessage(), &quot;ISSUED&quot;, StringComparison.OrdinalIgnoreCase);&#10;        }&#10;&#10;        private bool enrichTestQueue()&#10;        {&#10;            bool valid = false;&#10;            try&#10;            {&#10;                int counter = 0;&#10;                testQueue.Enqueue(enrichFile(ReaderHelper.readFileFromResource(&quot;samples/b2b_invoice.xml&quot;) ?? throw new Exception(&quot;Missing b2b_invoice&quot;), counter++));&#10;                testQueue.Enqueue(enrichFile(ReaderHelper.readFileFromResource(&quot;samples/b2b_credit.xml&quot;) ?? throw new Exception(&quot;Missing b2b_credit&quot;), counter++));&#10;                valid = true;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                log?.LogError(e, &quot;Failed to enrich test queue&quot;);&#10;                return false;&#10;            }&#10;            return valid;&#10;        }&#10;&#10;        private string enrichFile(string file, int counter)&#10;        {&#10;            string id = $&quot;{taxPayerNumber}_{deviceId}_{counter}&quot;;&#10;            string orgId = $&quot;{taxPayerNumber}_{deviceId}_{counter - 1}&quot;;&#10;            string formattedDate = DateTime.Now.ToString(DateFormat);&#10;            &#10;            string enrichedFile = file.Replace(&quot;${ID}&quot;, id);&#10;            enrichedFile = enrichedFile.Replace(&quot;${UUID}&quot;, CreateGuid(id).ToString());&#10;            enrichedFile = enrichedFile.Replace(&quot;${ISSUE_DATE}&quot;, formattedDate);&#10;            enrichedFile = enrichedFile.Replace(&quot;${ORG_ID}&quot;, orgId);&#10;            enrichedFile = enrichedFile.Replace(&quot;${ORG_UUID}&quot;, CreateGuid(orgId).ToString());&#10;            enrichedFile = enrichedFile.Replace(&quot;${VAT_NUMBER}&quot;, taxPayerNumber);&#10;            enrichedFile = enrichedFile.Replace(&quot;${TAXPAYER_NAME}&quot;, csrConfigDto.getEnName());&#10;            enrichedFile = enrichedFile.Replace(&quot;${DEVICE_ID}&quot;, deviceId);&#10;            return enrichedFile;&#10;        }&#10;&#10;        private Guid CreateGuid(string input)&#10;        {&#10;            using (var md5 = MD5.Create())&#10;            {&#10;                byte[] hash = md5.ComputeHash(Encoding.UTF8.GetBytes(input));&#10;                return new Guid(hash);&#10;            }&#10;        }&#10;&#10;        private string findLatestTimestamp()&#10;        {&#10;            try&#10;            {&#10;                DirectoryInfo dir = new DirectoryInfo(outputDirectory);&#10;                FileInfo[] files = dir.GetFiles(&quot;*.csr&quot;).Concat(dir.GetFiles(&quot;*.key&quot;)).ToArray();&#10;                if (files.Length == 0)&#10;                {&#10;                    return null;&#10;                }&#10;&#10;                string latestTimestamp = null;&#10;                foreach (FileInfo file in files)&#10;                {&#10;                    string fileName = file.Name;&#10;                    string[] parts = fileName.Split('_');&#10;                    if (parts.Length &gt;= 2)&#10;                    {&#10;                        string timestamp = parts[parts.Length - 1].Replace(&quot;.csr&quot;, &quot;&quot;).Replace(&quot;.key&quot;, &quot;&quot;);&#10;                        if (latestTimestamp == null || string.Compare(timestamp, latestTimestamp) &gt; 0)&#10;                        {&#10;                            latestTimestamp = timestamp;&#10;                        }&#10;                    }&#10;                }&#10;                return latestTimestamp;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                log?.LogError(e, &quot;Failed to find latest timestamp&quot;);&#10;                return null;&#10;            }&#10;        }&#10;&#10;        private string extractCommonNameFromDN(string subjectDn)&#10;        {&#10;            try&#10;            {&#10;                string[] parts = subjectDn.Split(',');&#10;                foreach (string part in parts)&#10;                {&#10;                    string trimmed = part.Trim();&#10;                    if (trimmed.ToUpper().StartsWith(&quot;CN=&quot;))&#10;                    {&#10;                        return Regex.Replace(trimmed.Substring(3).Trim(), @&quot;[^a-zA-Z0-9_-]&quot;, &quot;_&quot;);&#10;                    }&#10;                }&#10;                return &quot;CSR&quot;;&#10;            }&#10;            catch (Exception)&#10;            {&#10;                return &quot;CSR&quot;;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/utils/ECDSAUtils.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/utils/ECDSAUtils.cs" />
              <option name="originalContent" value="using System;&#10;using Org.BouncyCastle.Asn1;&#10;using Org.BouncyCastle.Asn1.Sec;&#10;using Org.BouncyCastle.Asn1.X9;&#10;using Org.BouncyCastle.Crypto;&#10;using Org.BouncyCastle.Crypto.Generators;&#10;using Org.BouncyCastle.Crypto.Parameters;&#10;using Org.BouncyCastle.Math;&#10;using Org.BouncyCastle.Security;&#10;using Org.BouncyCastle.OpenSsl;&#10;using System.IO;&#10;using System.Security.Cryptography;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.utils;&#10;public class ECDSAUtils&#10;{&#10;    public static AsymmetricCipherKeyPair getKeyPair()&#10;    {&#10;        var curve = SecNamedCurves.GetByName(&quot;secp256k1&quot;);&#10;        var domainParams = new ECDomainParameters(curve.Curve, curve.G, curve.N, curve.H);&#10;&#10;        &#10;        var keyGen = new ECKeyPairGenerator();&#10;        var secureRandom = new SecureRandom();&#10;        var keyGenParam = new ECKeyGenerationParameters(domainParams, secureRandom);&#10;        keyGen.Init(keyGenParam);&#10;        &#10;        return keyGen.GenerateKeyPair();&#10;    }&#10;&#10;    public static RSA getPrivateKey(string base64Key)&#10;    {&#10;        try&#10;        {&#10;            byte[] keyBytes = Convert.FromBase64String(base64Key);&#10;            &#10;            // Try to load as encrypted PKCS#8 first&#10;            try&#10;            {&#10;                RSA rsa = RSA.Create();&#10;                rsa.ImportPkcs8PrivateKey(keyBytes, out _);&#10;                return rsa;&#10;            }&#10;            catch&#10;            {&#10;                // If that fails, try as encrypted PKCS#8 with empty password&#10;                try&#10;                {&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportEncryptedPkcs8PrivateKey(&quot;&quot;, keyBytes, out _);&#10;                    return rsa;&#10;                }&#10;                catch&#10;                {&#10;                    // If both fail, try as RSA private key&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportRSAPrivateKey(keyBytes, out _);&#10;                    return rsa;&#10;                }&#10;            }&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            throw new ArgumentException(&quot;Failed to parse RSA private key: &quot; + ex.Message, ex);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using Org.BouncyCastle.Asn1;&#10;using Org.BouncyCastle.Asn1.Sec;&#10;using Org.BouncyCastle.Asn1.X9;&#10;using Org.BouncyCastle.Crypto;&#10;using Org.BouncyCastle.Crypto.Generators;&#10;using Org.BouncyCastle.Crypto.Parameters;&#10;using Org.BouncyCastle.Math;&#10;using Org.BouncyCastle.Security;&#10;using Org.BouncyCastle.OpenSsl;&#10;using System.IO;&#10;using System.Security.Cryptography;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.utils;&#10;public class ECDSAUtils&#10;{&#10;    public static AsymmetricCipherKeyPair getKeyPair()&#10;    {&#10;        var curve = SecNamedCurves.GetByName(&quot;secp256k1&quot;);&#10;        var domainParams = new ECDomainParameters(curve.Curve, curve.G, curve.N, curve.H);&#10;&#10;        &#10;        var keyGen = new ECKeyPairGenerator();&#10;        var secureRandom = new SecureRandom();&#10;        var keyGenParam = new ECKeyGenerationParameters(domainParams, secureRandom);&#10;        keyGen.Init(keyGenParam);&#10;        &#10;        return keyGen.GenerateKeyPair();&#10;    }&#10;&#10;    public static RSA getPrivateKey(string base64Key)&#10;    {&#10;        try&#10;        {&#10;            byte[] keyBytes = Convert.FromBase64String(base64Key);&#10;            &#10;            // Try to load as encrypted PKCS#8 first&#10;            try&#10;            {&#10;                RSA rsa = RSA.Create();&#10;                rsa.ImportPkcs8PrivateKey(keyBytes, out _);&#10;                return rsa;&#10;            }&#10;            catch&#10;            {&#10;                // If that fails, try as encrypted PKCS#8 with empty password&#10;                try&#10;                {&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportEncryptedPkcs8PrivateKey(&quot;&quot;, keyBytes, out _);&#10;                    return rsa;&#10;                }&#10;                catch&#10;                {&#10;                    // If both fail, try as RSA private key&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportRSAPrivateKey(keyBytes, out _);&#10;                    return rsa;&#10;                }&#10;            }&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            throw new ArgumentException(&quot;Failed to parse RSA private key: &quot; + ex.Message, ex);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/utils/PrivateKeyUtil.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/utils/PrivateKeyUtil.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Security.Cryptography;&#10;using System.Text;&#10;using ISTD_OFFLINE_CSHARP.utils;&#10;using Microsoft.Extensions.Logging;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.utils&#10;{&#10;    public static class PrivateKeyUtil&#10;    {&#10;        private static readonly ILogger log = LoggingUtils.getLoggerFactory().CreateLogger(typeof(PrivateKeyUtil));&#10;&#10;        public static RSA loadPrivateKey(string privateKeyContent, string password)&#10;        {&#10;            try&#10;            {&#10;                if (privateKeyContent.Contains(&quot;-----BEGIN ENCRYPTED PRIVATE KEY-----&quot;))&#10;                {&#10;                    return loadEncryptedPKCS8PrivateKey(privateKeyContent, password);&#10;                }&#10;                else if (privateKeyContent.Contains(&quot;-----BEGIN PRIVATE KEY-----&quot;))&#10;                {&#10;                    return loadUnencryptedPKCS8PrivateKey(privateKeyContent);&#10;                }&#10;                else&#10;                {&#10;                    return loadPrivateKeyFromBase64(privateKeyContent, password);&#10;                }&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                log.LogError(e, &quot;Failed to load private key&quot;);&#10;                throw new Exception(&quot;Unable to load private key: &quot; + e.Message, e);&#10;            }&#10;        }&#10;&#10;        private static RSA loadEncryptedPKCS8PrivateKey(string privateKeyContent, string password)&#10;        {&#10;            if (string.IsNullOrWhiteSpace(password))&#10;            {&#10;                throw new ArgumentException(&quot;Password is required for encrypted private key&quot;);&#10;            }&#10;&#10;            string cleanKey = privateKeyContent&#10;                .Replace(&quot;-----BEGIN ENCRYPTED PRIVATE KEY-----&quot;, &quot;&quot;)&#10;                .Replace(&quot;-----END ENCRYPTED PRIVATE KEY-----&quot;, &quot;&quot;)&#10;                .Replace(&quot;\n&quot;, &quot;&quot;)&#10;                .Replace(&quot;\r&quot;, &quot;&quot;)&#10;                .Replace(&quot; &quot;, &quot;&quot;);&#10;&#10;            byte[] keyBytes = Convert.FromBase64String(cleanKey);&#10;&#10;            RSA rsa = RSA.Create();&#10;            rsa.ImportEncryptedPkcs8PrivateKey(password, keyBytes, out _);&#10;            return rsa;&#10;        }&#10;&#10;        private static RSA loadUnencryptedPKCS8PrivateKey(string privateKeyContent)&#10;        {&#10;            string cleanKey = privateKeyContent&#10;                .Replace(&quot;-----BEGIN PRIVATE KEY-----&quot;, &quot;&quot;)&#10;                .Replace(&quot;-----END PRIVATE KEY-----&quot;, &quot;&quot;)&#10;                .Replace(&quot;\n&quot;, &quot;&quot;)&#10;                .Replace(&quot;\r&quot;, &quot;&quot;)&#10;                .Replace(&quot; &quot;, &quot;&quot;);&#10;&#10;            byte[] keyBytes = Convert.FromBase64String(cleanKey);&#10;&#10;            RSA rsa = RSA.Create();&#10;            rsa.ImportPkcs8PrivateKey(keyBytes, out _);&#10;            return rsa;&#10;        }&#10;&#10;        private static RSA loadPrivateKeyFromBase64(string privateKeyBase64, string password)&#10;        {&#10;            byte[] privateKeyBytes = Convert.FromBase64String(privateKeyBase64);&#10;&#10;            // Try to parse as PEM first&#10;            string pemContent = Encoding.UTF8.GetString(privateKeyBytes);&#10;            if (pemContent.Contains(&quot;-----BEGIN&quot;))&#10;            {&#10;                return loadPrivateKey(pemContent, password);&#10;            }&#10;&#10;            // Try as encrypted PKCS#8&#10;            if (!string.IsNullOrWhiteSpace(password))&#10;            {&#10;                try&#10;                {&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportEncryptedPkcs8PrivateKey(password, privateKeyBytes, out _);&#10;                    return rsa;&#10;                }&#10;                catch (Exception)&#10;                {&#10;                    // Fall through to try unencrypted&#10;                }&#10;            }&#10;&#10;            // Try as unencrypted PKCS#8&#10;            try&#10;            {&#10;                RSA rsa = RSA.Create();&#10;                rsa.ImportPkcs8PrivateKey(privateKeyBytes, out _);&#10;                return rsa;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                throw new Exception(&quot;Unable to parse private key format: &quot; + e.Message, e);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>