<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/processor/impl/InvoiceSignProcessor.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/processor/impl/InvoiceSignProcessor.cs" />
              <option name="originalContent" value="using System.Security.Cryptography;&#10;using ISTD_OFFLINE_CSHARP.DTOs;&#10;using ISTD_OFFLINE_CSHARP.helper;&#10;using ISTD_OFFLINE_CSHARP.Helper;&#10;using ISTD_OFFLINE_CSHARP.io;&#10;using ISTD_OFFLINE_CSHARP.security;&#10;using ISTD_OFFLINE_CSHARP.utils;&#10;using Microsoft.Extensions.Logging;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.ActionProcessor.impl;&#10;&#10;public class InvoiceSignProcessor : processor.ActionProcessor&#10;{&#10;    private readonly ILogger log;&#10;    private readonly SigningHelper signingHelper;&#10;    private string xmlPath = &quot;&quot;;&#10;    private string privateKeyPath = &quot;&quot;;&#10;    private string certificatePath = &quot;&quot;;&#10;    private string outputFile = &quot;&quot;;&#10;    private string keyPassword = &quot;&quot;;&#10;    private RSA privateKey;&#10;    private string xmlFile = &quot;&quot;;&#10;    private string certificateStr = &quot;&quot;;&#10;    private EInvoiceSigningResults signingResults;&#10;&#10;    public InvoiceSignProcessor()&#10;    {&#10;        this.log = LoggingUtils.getLoggerFactory().CreateLogger&lt;InvoiceSignProcessor&gt;();&#10;        this.signingHelper = new SigningHelper();&#10;    }&#10;&#10;    protected override bool loadArgs(string[] args)&#10;    {&#10;        if (args.Length &lt; 4 || args.Length &gt; 5)&#10;        {&#10;            log?.LogInformation(&quot;Usage: dotnet run invoice-sign &lt;xml-path&gt; &lt;private-key-path&gt; &lt;certificate-path&gt; &lt;output-file&gt; [key-password]&quot;);&#10;            return false;&#10;        }&#10;        xmlPath = args[0];&#10;        privateKeyPath = args[1];&#10;        certificatePath = args[2];&#10;        outputFile = args[3];&#10;        keyPassword = args.Length == 5 ? args[4] : &quot;&quot;;&#10;        return true;&#10;    }&#10;    &#10;    protected override bool validateArgs()&#10;    {&#10;        if (string.IsNullOrWhiteSpace(outputFile))&#10;        {&#10;            log?.LogInformation(&quot;Invalid output path&quot;);&#10;            return false;&#10;        }&#10;&#10;        if (!readXmlFile()) return false;&#10;        if (!readPrivateKey()) return false;&#10;        return readCertificate();&#10;    }&#10;&#10;    protected override bool process()&#10;    {&#10;        if (signingHelper == null)&#10;        {&#10;            log?.LogError(&quot;SigningHelper is null. Initialization missing.&quot;);&#10;            return false;&#10;        }&#10;        &#10;        signingResults = signingHelper.signEInvoice(xmlFile, privateKey, certificateStr);&#10;        return signingResults != null &amp;&amp; !string.IsNullOrWhiteSpace(signingResults.getSignedXml());&#10;    }&#10;    &#10;    protected override bool output()&#10;    {&#10;        log?.LogInformation($@&quot;&#10;        invoice UUID [{signingResults.getInvoiceUUID()}]&#10;        invoice Hash [{signingResults.getInvoiceHash()}]&#10;        invoice QR Code: [{signingResults.getQrCode()}]&#10;        &quot;);&#10;&#10;        return WriterHelper.writeFile(outputFile, signingResults.getSignedXml());&#10;    }&#10;    &#10;    private bool readCertificate()&#10;    {&#10;        certificateStr = ReaderHelper.readFileAsString(certificatePath);&#10;        if (string.IsNullOrWhiteSpace(certificateStr))&#10;        {&#10;            log?.LogInformation($&quot;Certificate file [{certificatePath}] is empty&quot;);&#10;            return false;&#10;        }&#10;        certificateStr = SecurityUtils.decrypt(certificateStr);&#10;        return true;&#10;    }&#10;    &#10;    private bool readPrivateKey()&#10;    {&#10;        string privateKeyFile = ReaderHelper.readFileAsString(privateKeyPath);&#10;        if (string.IsNullOrWhiteSpace(privateKeyFile))&#10;        {&#10;            log?.LogInformation($&quot;Private key file [{privateKeyPath}] is empty&quot;);&#10;            return false;&#10;        }&#10;        try&#10;        {&#10;            privateKeyFile = SecurityUtils.decrypt(privateKeyFile);&#10;            &#10;            // Use the new PrivateKeyUtil to load the private key&#10;            privateKey = PrivateKeyUtil.loadPrivateKey(privateKeyFile, keyPassword);&#10;        }&#10;        catch (Exception e)&#10;        {&#10;            log?.LogError(e, $&quot;Failed to read private key [{privateKeyPath}]&quot;);&#10;            return false;&#10;        }&#10;        return true;&#10;    }&#10;   &#10;    private bool readXmlFile()&#10;    {&#10;        xmlFile = ReaderHelper.readFileAsString(xmlPath);&#10;        if (string.IsNullOrWhiteSpace(xmlFile))&#10;        {&#10;            log?.LogInformation($&quot;XML file [{xmlPath}] is empty&quot;);&#10;            return false;&#10;        }&#10;        return true;&#10;    }&#10;&#10;&#10;}" />
              <option name="updatedContent" value="using System.Security.Cryptography;&#10;using ISTD_OFFLINE_CSHARP.DTOs;&#10;using ISTD_OFFLINE_CSHARP.helper;&#10;using ISTD_OFFLINE_CSHARP.Helper;&#10;using ISTD_OFFLINE_CSHARP.io;&#10;using ISTD_OFFLINE_CSHARP.security;&#10;using ISTD_OFFLINE_CSHARP.utils;&#10;using Microsoft.Extensions.Logging;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.ActionProcessor.impl;&#10;&#10;public class InvoiceSignProcessor : processor.ActionProcessor&#10;{&#10;    private readonly ILogger log;&#10;    private readonly SigningHelper signingHelper;&#10;    private string xmlPath = &quot;&quot;;&#10;    private string privateKeyPath = &quot;&quot;;&#10;    private string certificatePath = &quot;&quot;;&#10;    private string outputFile = &quot;&quot;;&#10;    private string keyPassword = &quot;&quot;;&#10;    private RSA privateKey;&#10;    private string xmlFile = &quot;&quot;;&#10;    private string certificateStr = &quot;&quot;;&#10;    private EInvoiceSigningResults signingResults;&#10;&#10;    public InvoiceSignProcessor()&#10;    {&#10;        this.log = LoggingUtils.getLoggerFactory().CreateLogger&lt;InvoiceSignProcessor&gt;();&#10;        this.signingHelper = new SigningHelper();&#10;    }&#10;&#10;    protected override bool loadArgs(string[] args)&#10;    {&#10;        if (args.Length &lt; 4 || args.Length &gt; 5)&#10;        {&#10;            log?.LogInformation(&quot;Usage: dotnet run invoice-sign &lt;xml-path&gt; &lt;private-key-path&gt; &lt;certificate-path&gt; &lt;output-file&gt; [key-password]&quot;);&#10;            return false;&#10;        }&#10;        xmlPath = args[0];&#10;        privateKeyPath = args[1];&#10;        certificatePath = args[2];&#10;        outputFile = args[3];&#10;        keyPassword = args.Length == 5 ? args[4] : &quot;&quot;;&#10;        return true;&#10;    }&#10;    &#10;    protected override bool validateArgs()&#10;    {&#10;        if (string.IsNullOrWhiteSpace(outputFile))&#10;        {&#10;            log?.LogInformation(&quot;Invalid output path&quot;);&#10;            return false;&#10;        }&#10;&#10;        if (!readXmlFile()) return false;&#10;        if (!readPrivateKey()) return false;&#10;        return readCertificate();&#10;    }&#10;&#10;    protected override bool process()&#10;    {&#10;        if (signingHelper == null)&#10;        {&#10;            log?.LogError(&quot;SigningHelper is null. Initialization missing.&quot;);&#10;            return false;&#10;        }&#10;        &#10;        signingResults = signingHelper.signEInvoice(xmlFile, privateKey, certificateStr);&#10;        return signingResults != null &amp;&amp; !string.IsNullOrWhiteSpace(signingResults.getSignedXml());&#10;    }&#10;    &#10;    protected override bool output()&#10;    {&#10;        log?.LogInformation($@&quot;&#10;        invoice UUID [{signingResults.getInvoiceUUID()}]&#10;        invoice Hash [{signingResults.getInvoiceHash()}]&#10;        invoice QR Code: [{signingResults.getQrCode()}]&#10;        &quot;);&#10;&#10;        return WriterHelper.writeFile(outputFile, signingResults.getSignedXml());&#10;    }&#10;    &#10;    private bool readCertificate()&#10;    {&#10;        certificateStr = ReaderHelper.readFileAsString(certificatePath);&#10;        if (string.IsNullOrWhiteSpace(certificateStr))&#10;        {&#10;            log?.LogInformation($&quot;Certificate file [{certificatePath}] is empty&quot;);&#10;            return false;&#10;        }&#10;        certificateStr = SecurityUtils.decrypt(certificateStr);&#10;        return true;&#10;    }&#10;    &#10;    private bool readPrivateKey()&#10;    {&#10;        string privateKeyFile = ReaderHelper.readFileAsString(privateKeyPath);&#10;        if (string.IsNullOrWhiteSpace(privateKeyFile))&#10;        {&#10;            log?.LogInformation($&quot;Private key file [{privateKeyPath}] is empty&quot;);&#10;            return false;&#10;        }&#10;        try&#10;        {&#10;            privateKeyFile = SecurityUtils.decrypt(privateKeyFile);&#10;            &#10;            // Use the new PrivateKeyUtil to load the private key&#10;            privateKey = PrivateKeyUtil.loadPrivateKey(privateKeyFile, keyPassword);&#10;        }&#10;        catch (Exception e)&#10;        {&#10;            log?.LogError(e, $&quot;Failed to read private key [{privateKeyPath}]&quot;);&#10;            return false;&#10;        }&#10;        return true;&#10;    }&#10;   &#10;    private bool readXmlFile()&#10;    {&#10;        xmlFile = ReaderHelper.readFileAsString(xmlPath);&#10;        if (string.IsNullOrWhiteSpace(xmlFile))&#10;        {&#10;            log?.LogInformation($&quot;XML file [{xmlPath}] is empty&quot;);&#10;            return false;&#10;        }&#10;        return true;&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/utils/ECDSAUtils.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/utils/ECDSAUtils.cs" />
              <option name="originalContent" value="using System;&#10;using Org.BouncyCastle.Asn1;&#10;using Org.BouncyCastle.Asn1.Sec;&#10;using Org.BouncyCastle.Asn1.X9;&#10;using Org.BouncyCastle.Crypto;&#10;using Org.BouncyCastle.Crypto.Generators;&#10;using Org.BouncyCastle.Crypto.Parameters;&#10;using Org.BouncyCastle.Math;&#10;using Org.BouncyCastle.Security;&#10;using Org.BouncyCastle.OpenSsl;&#10;using System.IO;&#10;using System.Security.Cryptography;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.utils;&#10;public class ECDSAUtils&#10;{&#10;    public static AsymmetricCipherKeyPair getKeyPair()&#10;    {&#10;        var curve = SecNamedCurves.GetByName(&quot;secp256k1&quot;);&#10;        var domainParams = new ECDomainParameters(curve.Curve, curve.G, curve.N, curve.H);&#10;&#10;        &#10;        var keyGen = new ECKeyPairGenerator();&#10;        var secureRandom = new SecureRandom();&#10;        var keyGenParam = new ECKeyGenerationParameters(domainParams, secureRandom);&#10;        keyGen.Init(keyGenParam);&#10;        &#10;        return keyGen.GenerateKeyPair();&#10;    }&#10;&#10;    public static RSA getPrivateKey(string base64Key)&#10;    {&#10;        try&#10;        {&#10;            byte[] keyBytes = Convert.FromBase64String(base64Key);&#10;            &#10;            // Try to load as encrypted PKCS#8 first&#10;            try&#10;            {&#10;                RSA rsa = RSA.Create();&#10;                rsa.ImportPkcs8PrivateKey(keyBytes, out _);&#10;                return rsa;&#10;            }&#10;            catch&#10;            {&#10;                // If that fails, try as encrypted PKCS#8 with empty password&#10;                try&#10;                {&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportEncryptedPkcs8PrivateKey(&quot;&quot;, keyBytes, out _);&#10;                    return rsa;&#10;                }&#10;                catch&#10;                {&#10;                    // If both fail, try as RSA private key&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportRSAPrivateKey(keyBytes, out _);&#10;                    return rsa;&#10;                }&#10;            }&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            throw new ArgumentException(&quot;Failed to parse RSA private key: &quot; + ex.Message, ex);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using Org.BouncyCastle.Asn1;&#10;using Org.BouncyCastle.Asn1.Sec;&#10;using Org.BouncyCastle.Asn1.X9;&#10;using Org.BouncyCastle.Crypto;&#10;using Org.BouncyCastle.Crypto.Generators;&#10;using Org.BouncyCastle.Crypto.Parameters;&#10;using Org.BouncyCastle.Math;&#10;using Org.BouncyCastle.Security;&#10;using Org.BouncyCastle.OpenSsl;&#10;using System.IO;&#10;using System.Security.Cryptography;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.utils;&#10;public class ECDSAUtils&#10;{&#10;    public static AsymmetricCipherKeyPair getKeyPair()&#10;    {&#10;        var curve = SecNamedCurves.GetByName(&quot;secp256k1&quot;);&#10;        var domainParams = new ECDomainParameters(curve.Curve, curve.G, curve.N, curve.H);&#10;&#10;        &#10;        var keyGen = new ECKeyPairGenerator();&#10;        var secureRandom = new SecureRandom();&#10;        var keyGenParam = new ECKeyGenerationParameters(domainParams, secureRandom);&#10;        keyGen.Init(keyGenParam);&#10;        &#10;        return keyGen.GenerateKeyPair();&#10;    }&#10;&#10;    public static RSA getPrivateKey(string base64Key)&#10;    {&#10;        try&#10;        {&#10;            byte[] keyBytes = Convert.FromBase64String(base64Key);&#10;            &#10;            // Try to load as encrypted PKCS#8 first&#10;            try&#10;            {&#10;                RSA rsa = RSA.Create();&#10;                rsa.ImportPkcs8PrivateKey(keyBytes, out _);&#10;                return rsa;&#10;            }&#10;            catch&#10;            {&#10;                // If that fails, try as encrypted PKCS#8 with empty password&#10;                try&#10;                {&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportEncryptedPkcs8PrivateKey(&quot;&quot;, keyBytes, out _);&#10;                    return rsa;&#10;                }&#10;                catch&#10;                {&#10;                    // If both fail, try as RSA private key&#10;                    RSA rsa = RSA.Create();&#10;                    rsa.ImportRSAPrivateKey(keyBytes, out _);&#10;                    return rsa;&#10;                }&#10;            }&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            throw new ArgumentException(&quot;Failed to parse RSA private key: &quot; + ex.Message, ex);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/utils/PrivateKeyUtil.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/utils/PrivateKeyUtil.cs" />
              <option name="originalContent" value="&#10;&#10;&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.IO;&#10;using System.Security.Cryptography;&#10;using System.Text;&#10;using Org.BouncyCastle.OpenSsl;&#10;using Org.BouncyCastle.Pkcs;&#10;using Org.BouncyCastle.Crypto;&#10;using Microsoft.Extensions.Logging;&#10;using ISTD_OFFLINE_CSHARP.utils;&#10;&#10;namespace ISTD_OFFLINE_CSHARP.utils&#10;{&#10;    public static class PrivateKeyUtil&#10;    {&#10;        private static readonly ILogger log = LoggingUtils.getLoggerFactory().CreateLogger(typeof(PrivateKeyUtil));&#10;&#10;        public static RSA loadPrivateKey(string privateKeyContent, string password = &quot;&quot;)&#10;        {&#10;            if (privateKeyContent.Contains(&quot;-----BEGIN ENCRYPTED PRIVATE KEY-----&quot;))&#10;            {&#10;                return loadEncryptedPKCS8PrivateKey(privateKeyContent, password);&#10;            }&#10;            else if (privateKeyContent.Contains(&quot;-----BEGIN PRIVATE KEY-----&quot;))&#10;            {&#10;                return loadUnencryptedPKCS8PrivateKey(privateKeyContent);&#10;            }&#10;            else if (privateKeyContent.Contains(&quot;-----BEGIN RSA PRIVATE KEY-----&quot;))&#10;            {&#10;                return loadRSAPrivateKey(privateKeyContent);&#10;            }&#10;            else&#10;            {&#10;                return loadPrivateKeyFromBase64(privateKeyContent, password);&#10;            }&#10;        }&#10;&#10;        private static RSA loadEncryptedPKCS8PrivateKey(string privateKeyContent, string password)&#10;        {&#10;            try&#10;            {&#10;                using var stringReader = new StringReader(privateKeyContent);&#10;                using var pemReader = new PemReader(stringReader, new PasswordFinder(password));&#10;                &#10;                var keyObject = pemReader.ReadObject();&#10;                &#10;                if (keyObject is AsymmetricCipherKeyPair keyPair)&#10;                {&#10;                    return convertToRSA(keyPair.Private);&#10;                }&#10;                else if (keyObject is AsymmetricKeyParameter keyParam)&#10;                {&#10;                    return convertToRSA(keyParam);&#10;                }&#10;                else&#10;                {&#10;                    throw new Exception(&quot;Expected encrypted private key but found different format&quot;);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                log.LogError(ex, &quot;Failed to load encrypted PKCS8 private key&quot;);&#10;                throw new Exception(&quot;Failed to load encrypted PKCS8 private key: &quot; + ex.Message, ex);&#10;            }&#10;        }&#10;&#10;        private static RSA loadUnencryptedPKCS8PrivateKey(string privateKeyContent)&#10;        {&#10;            try&#10;            {&#10;                string cleanKey = privateKeyContent&#10;                    .Replace(&quot;-----BEGIN PRIVATE KEY-----&quot;, &quot;&quot;)&#10;                    .Replace(&quot;-----END PRIVATE KEY-----&quot;, &quot;&quot;)&#10;                    .Replace(&quot;\r&quot;, &quot;&quot;)&#10;                    .Replace(&quot;\n&quot;, &quot;&quot;)&#10;                    .Replace(&quot; &quot;, &quot;&quot;)&#10;                    .Replace(&quot;\t&quot;, &quot;&quot;);&#10;&#10;                byte[] keyBytes = Convert.FromBase64String(cleanKey);&#10;                &#10;                RSA rsa = RSA.Create();&#10;                rsa.ImportPkcs8PrivateKey(keyBytes, out _);&#10;                return rsa;&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                log.LogError(ex, &quot;Failed to load unencrypted PKCS8 private key&quot;);&#10;                throw new Exception(&quot;Failed to load unencrypted PKCS8 private key: &quot; + ex.Message, ex);&#10;            }&#10;        }&#10;&#10;        private static RSA loadRSAPrivateKey(string privateKeyContent)&#10;        {&#10;            try&#10;            {&#10;                using var stringReader = new StringReader(privateKeyContent);&#10;                using var pemReader = new PemReader(stringReader);&#10;                &#10;                var keyObject = pemReader.ReadObject();&#10;                &#10;                if (keyObject is AsymmetricCipherKeyPair keyPair)&#10;                {&#10;                    return convertToRSA(keyPair.Private);&#10;                }&#10;                else if (keyObject is AsymmetricKeyParameter keyParam)&#10;                {&#10;                    return convertToRSA(keyParam);&#10;                }&#10;                else&#10;                {&#10;                    throw new Exception(&quot;Unable to parse RSA private key format&quot;);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                log.LogError(ex, &quot;Failed to load RSA private key&quot;);&#10;                throw new Exception(&quot;Failed to load RSA private key: &quot; + ex.Message, ex);&#10;            }&#10;        }&#10;&#10;        private static RSA loadPrivateKeyFromBase64(string privateKeyBase64, string password)&#10;        {&#10;            try&#10;            {&#10;                byte[] privateKeyBytes = Convert.FromBase64String(privateKeyBase64);&#10;                log.LogInformation($&quot;Loaded {privateKeyBytes.Length} bytes from base64&quot;);&#10;&#10;                // Try to parse as PEM first&#10;                string pemContent = Encoding.UTF8.GetString(privateKeyBytes);&#10;                if (pemContent.Contains(&quot;-----BEGIN&quot;))&#10;                {&#10;                    log.LogInformation(&quot;Detected PEM format, delegating to PEM parser&quot;);&#10;                    return loadPrivateKey(pemContent, password);&#10;                }&#10;&#10;                // Try encrypted PKCS8 first&#10;                try&#10;                {&#10;                    log.LogInformation(&quot;Attempting encrypted PKCS8 import&quot;);&#10;                    RSA rsa = RSA.Create();&#10;                    if (!string.IsNullOrEmpty(password))&#10;                    {&#10;                        rsa.ImportEncryptedPkcs8PrivateKey(password, privateKeyBytes, out _);&#10;                        log.LogInformation(&quot;Successfully imported encrypted PKCS8 private key&quot;);&#10;                    }&#10;                    else&#10;                    {&#10;                        rsa.ImportPkcs8PrivateKey(privateKeyBytes, out _);&#10;                        log.LogInformation(&quot;Successfully imported unencrypted PKCS8 private key&quot;);&#10;                    }&#10;                    return rsa;&#10;                }&#10;                catch (Exception encryptedException)&#10;                {&#10;                    log.LogWarning($&quot;Encrypted PKCS8 failed: {encryptedException.Message}&quot;);&#10;                    // Try unencrypted PKCS8&#10;                    try&#10;                    {&#10;                        log.LogInformation(&quot;Attempting unencrypted PKCS8 import&quot;);&#10;                        RSA rsa = RSA.Create();&#10;                        rsa.ImportPkcs8PrivateKey(privateKeyBytes, out _);&#10;                        log.LogInformation(&quot;Successfully imported PKCS8 private key&quot;);&#10;                        return rsa;&#10;                    }&#10;                    catch (Exception pkcs8Exception)&#10;                    {&#10;                        log.LogWarning($&quot;PKCS8 failed: {pkcs8Exception.Message}&quot;);&#10;                        // Try RSA private key format&#10;                        try&#10;                        {&#10;                            log.LogInformation(&quot;Attempting RSA private key import&quot;);&#10;                            RSA rsa = RSA.Create();&#10;                            rsa.ImportRSAPrivateKey(privateKeyBytes, out _);&#10;                            log.LogInformation(&quot;Successfully imported RSA private key&quot;);&#10;                            return rsa;&#10;                        }&#10;                        catch (Exception rsaException)&#10;                        {&#10;                            log.LogError($&quot;All import methods failed - RSA: {rsaException.Message}&quot;);&#10;                            throw new Exception($&quot;Unable to parse private key format. &quot; +&#10;                                              $&quot;Encrypted PKCS#8 error: {encryptedException.Message}, &quot; +&#10;                                              $&quot;PKCS#8 error: {pkcs8Exception.Message}, &quot; +&#10;                                              $&quot;RSA error: {rsaException.Message}&quot;);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                log.LogError(ex, &quot;Failed to load private key from base64&quot;);&#10;                throw new Exception(&quot;Failed to load private key from base64: &quot; + ex.Message, ex);&#10;            }&#10;        }&#10;&#10;        private static RSA convertToRSA(AsymmetricKeyParameter privateKey)&#10;        {&#10;            try&#10;            {&#10;                if (privateKey is Org.BouncyCastle.Crypto.Parameters.RsaPrivateCrtKeyParameters rsaKey)&#10;                {&#10;                    var rsa = RSA.Create();&#10;                    var parameters = new RSAParameters&#10;                    {&#10;                        Modulus = rsaKey.Modulus.ToByteArrayUnsigned(),&#10;                        Exponent = rsaKey.PublicExponent.ToByteArrayUnsigned(),&#10;                        D = rsaKey.Exponent.ToByteArrayUnsigned(), // Private exponent&#10;                        P = rsaKey.P.ToByteArrayUnsigned(),&#10;                        Q = rsaKey.Q.ToByteArrayUnsigned(),&#10;                        DP = rsaKey.DP.ToByteArrayUnsigned(),&#10;                        DQ = rsaKey.DQ.ToByteArrayUnsigned(),&#10;                        InverseQ = rsaKey.QInv.ToByteArrayUnsigned()&#10;                    };&#10;                    rsa.ImportParameters(parameters);&#10;                    return rsa;&#10;                }&#10;                else&#10;                {&#10;                    throw new Exception(&quot;Only RSA private keys are supported&quot;);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                log.LogError(ex, &quot;Failed to convert BouncyCastle key to RSA&quot;);&#10;                throw new Exception(&quot;Failed to convert BouncyCastle key to RSA: &quot; + ex.Message, ex);&#10;            }&#10;        }&#10;&#10;        private class PasswordFinder : IPasswordFinder&#10;        {&#10;            private readonly string password;&#10;&#10;            public PasswordFinder(string password)&#10;            {&#10;                this.password = password ?? &quot;&quot;;&#10;            }&#10;&#10;            public char[] GetPassword()&#10;            {&#10;                return password.ToCharArray();&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>